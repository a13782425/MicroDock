# MicroDock 项目开发规范

## 1. 项目概述

### 1.1 项目简介
MicroDock 是一个基于 Avalonia UI 开发的 Windows 桌面 Dock 栏应用程序，提供现代化的应用启动和管理体验，支持插件扩展、迷你模式、自动隐藏等功能。

### 1.2 技术栈
- **UI 框架**: Avalonia UI 11.3.8 + FluentAvaloniaUI 2.4.0
- **MVVM 框架**: ReactiveUI.Avalonia 11.3.8
- **开发平台**: .NET 8.0 (Windows 10.0.17763.0+)
- **数据库**: SQLite (sqlite-net-pcl 1.9.172 + SQLiteNetExtensions 2.1.0)
- **日志**: Serilog 4.3.0
- **桌面通知**: DesktopNotifications 1.3.1
- **系统图标**: System.Drawing.Common 10.0.0

### 1.4 UI 设计原则
- **Fluent Design**: 遵循微软 Fluent Design System 设计语言
- **现代化控件**: 优先使用 FluentAvalonia 提供的现代化控件
- **主题适配**: 支持明暗主题自动切换，使用系统强调色
- **响应式设计**: 适配不同窗口尺寸和屏幕分辨率
- **无障碍支持**: 考虑键盘导航和屏幕阅读器支持

### 1.3 架构模式
- **MVVM 模式**: 使用 ReactiveUI 实现数据绑定和命令绑定
- **服务定位器模式**: 通过 ServiceLocator 管理服务依赖
- **事件聚合器模式**: 使用 EventAggregator 实现模块间松耦合通信
- **插件架构**: 基于 AssemblyLoadContext 的动态插件加载

## 2. 代码组织规范

### 2.1 项目结构
```
MicroDock/
├── MicroDock/                    # 主应用程序
│   ├── ViewModels/              # MVVM 视图模型层
│   ├── Views/                   # UI 视图层
│   │   ├── Tabs/               # 标签页视图
│   │   └── Controls/           # 自定义控件
│   ├── Models/                 # 数据模型层
│   ├── Services/               # 业务服务层
│   │   └── Platform/          # 平台特定服务
│   ├── Database/              # 数据访问层
│   ├── Extension/             # 扩展和转换器
│   ├── Infrastructure/         # 基础设施
│   └── Plugin/                 # 插件相关
├── MicroDock.Plugin/           # 插件框架
├── Test/                      # 测试插件示例
├── Plugin/                     # 插件目录
└── docs/                      # 项目文档
```

### 2.2 命名规范

#### 2.2.1 命名空间规范
- **项目命名空间**: `MicroDock`
- **模块命名空间**: `MicroDock.ViewModels`, `MicroDock.Views`, `MicroDock.Services`
- **功能命名空间**: `MicroDock.Services.Platform`, `MicroDock.Extension`
- **插件命名空间**: 插件开发者可自定义，建议使用 `YourCompany.MicroDock.Plugins.PluginName`

#### 2.2.2 类和接口命名
- **ViewModel 类**: 以 `ViewModel` 结尾，如 `MainWindowViewModel`, `ApplicationTabViewModel`
- **View 类**: 以 `View` 或 `Control` 结尾，如 `ApplicationTabView`, `AppItemControl`
- **Model 类**: 简洁明了的名称，如 `TabItemModel`, `LogEntry`
- **Service 类**: 以 `Service` 结尾，如 `IconService`, `AutoHideService`
- **接口命名**: 以 `I` 开头，如 `IWindowService`, `IPlatformIconService`

#### 2.2.3 方法和属性命名
- **方法**: 使用 PascalCase，动词开头，如 `GetApplicationIcon()`, `InitializeServices()`
- **属性**: 使用 PascalCase，名词形式，如 `ApplicationName`, `IsLoading`
- **私有字段**: 使用 `_camelCase`，如 `_applications`, `_isLoading`
- **常量**: 使用 PascalCase，如 `MaxRetryCount`, `DefaultTimeout`

### 2.3 文件组织规范

#### 2.3.1 文件命名
- **类文件**: 与类名相同，如 `MainWindowViewModel.cs`
- **视图文件**: AXAML 文件与对应类同名，如 `MainWindow.axaml`
- **代码后端**: AXAML 对应的代码后端文件，如 `MainWindow.axaml.cs`

#### 2.3.2 文件内容组织
```csharp
// 文件头部注释（可选）
using System;
using System.Collections.Generic;
using ReactiveUI;

namespace MicroDock.ViewModels
{
    /// <summary>
    /// 类的功能描述
    /// </summary>
    public class ExampleViewModel : ViewModelBase
    {
        // 字段声明（私有字段）
        private readonly IService _service;
        private string _property;

        // 构造函数
        public ExampleViewModel(IService service)
        {
            _service = service;
            InitializeCommands();
        }

        // 公共属性
        public string Property
        {
            get => _property;
            set => this.RaiseAndSetIfChanged(ref _property, value);
        }

        // 公共命令
        public ReactiveCommand<Unit, Unit> DoSomethingCommand { get; private set; }

        // 私有方法
        private void InitializeCommands()
        {
            DoSomethingCommand = ReactiveCommand.Create(DoSomething);
        }

        private void DoSomething()
        {
            // 实现逻辑
        }
    }
}
```

## 3. MVVM 开发规范

### 3.1 ViewModel 规范

#### 3.1.1 ViewModel 基类
所有 ViewModel 必须继承自 `ViewModelBase`（继承自 ReactiveUI 的 `ReactiveObject`）：

```csharp
public class MyViewModel : ViewModelBase
{
    // ViewModel 实现
}
```

#### 3.1.2 属性定义
使用 ReactiveUI 的 `RaiseAndSetIfChanged` 方法实现属性变更通知：

```csharp
private string _title;
public string Title
{
    get => _title;
    set => this.RaiseAndSetIfChanged(ref _title, value);
}
```

#### 3.1.3 命令定义
使用 `ReactiveCommand` 定义命令：

```csharp
public ReactiveCommand<Unit, Unit> SaveCommand { get; private set; }

// 在构造函数中初始化
SaveCommand = ReactiveCommand.Create(Save);
// 或者带参数的命令
SaveCommand = ReactiveCommand.Create<string>(SaveWithParameter);
```

### 3.2 View 规范

#### 3.2.1 FluentAvalonia 控件使用原则

**优先使用 FluentAvalonia 控件**
为保持视觉一致性和现代化用户体验，优先使用 FluentAvalonia 提供的控件替代原生 Avalonia 控件：

```xml
<!-- 推荐使用 FluentAvalonia 控件 -->
<fa:NavigationView />                    <!-- 替代原生 TreeView/TabControl -->
<fa:ContentDialog />                     <!-- 替代原生 Window/Dialog -->
<fa: TeachingTip />                      <!-- 替代自定义 Tooltip -->
<fa:ProgressBar />                       <!-- 替代原生 ProgressBar -->
<fa:ProgressRing />                      <!-- 替代原生 ProgressRing -->
<fa:SettingsCard />                      <!-- 用于设置页面项 -->
<fa:SettingsExpander />                  <!-- 用于可展开设置项 -->
<fa:NumberBox />                         <!-- 替代原生 NumericUpDown -->
<fa:ColorPicker />                       <!-- 替代原生 ColorPicker -->
<fa:SplitView />                         <!-- 替代原生 SplitView -->
<fa:InfoBar />                           <!-- 替代自定义提示控件 -->
<fa:TabView />                           <!-- 替代原生 TabControl -->
<fa:CommandBar />                        <!-- 用于工具栏 -->
<fa:AppBarButton />                      <!-- 用于工具栏按钮 -->
<fa:MenuFlyout />                        <!-- 替代原生 ContextMenu -->
<fa:DropDownButton />                    <!-- 用于下拉按钮 -->
<fa:ToggleSwitch />                      <!-- 替代原生 CheckBox（开关场景）-->
```

**控件选择指南**
- **导航**: 使用 `NavigationView` 实现侧边栏导航
- **对话框**: 使用 `ContentDialog` 创建现代化对话框
- **设置界面**: 使用 `SettingsCard` 和 `SettingsExpander` 构建设置页面
- **工具栏**: 使用 `CommandBar` 和 `AppBarButton` 构建工具栏
- **提示信息**: 使用 `TeachingTip` 提供上下文提示
- **状态通知**: 使用 `InfoBar` 显示状态信息
- **数据输入**: 使用 `NumberBox` 等专用输入控件

**样式和主题**
- 使用 `FluentAvaloniaTheme` 自动适配系统主题
- 支持 `PreferUserAccentColor="True"` 使用系统强调色
- 使用动态资源 `{DynamicResource SystemAccentColor}` 引用系统颜色

#### 3.2.2 AXAML 文件结构
```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="clr-namespace:MicroDock.ViewModels"
             xmlns:fa="clr-namespace:FluentAvalonia.UI.Controls;assembly=FluentAvalonia"
             mc:Ignorable="d" d:DesignWidth="500" d:DesignHeight="350"
             x:Class="MicroDock.Views.MyView"
             x:DataType="vm:MyViewModel">

    <!-- DataContext 设置 -->
    <UserControl.DataContext>
        <vm:MyViewModel/>
    </UserControl.DataContext>

    <!-- UI 内容 -->
    <Grid>
        <!-- 使用 FluentAvalonia 控件 -->
        <fa:InfoBar Severity="{Binding NotificationLevel}"
                    Message="{Binding NotificationMessage}"
                    IsOpen="{Binding ShowNotification}" />

        <StackPanel Spacing="12">
            <fa:SettingsCard Header="设置项"
                             Description="这是设置项的描述"
                             IsEnabled="{Binding IsSettingEnabled}">
                <fa:ToggleSwitch IsOn="{Binding SettingValue}" />
            </fa:SettingsCard>

            <fa:NumberBox Value="{Binding NumericValue}"
                          Header="数值输入"
                          Minimum="0"
                          Maximum="100" />
        </StackPanel>
    </Grid>
</UserControl>
```

#### 3.2.2 数据绑定
- **属性绑定**: `{Binding PropertyName}`
- **命令绑定**: `{Binding CommandName}`
- **双向绑定**: `{Binding PropertyName, Mode=TwoWay}`
- **转换器绑定**: `{Binding Property, Converter={StaticResource MyConverter}}`

#### 3.2.3 样式和资源
- 在 `App.axaml` 中定义全局样式
- 在控件级别定义局部样式
- 使用动态资源支持主题切换

#### 3.2.4 FluentAvalonia 样式定制

**系统颜色使用**
```xml
<!-- 使用系统颜色确保主题一致性 -->
<Border Background="{DynamicResource SystemAccentColor}" />
<TextBlock Foreground="{DynamicResource SystemAccentColorLight2}" />
<Style Selector="fa|NavigationViewItem:selected /template/ Border#LayoutRoot">
    <Setter Property="Background" Value="{DynamicResource SystemAccentColorLight2}"/>
</Style>
```

**控件样式定制**
```xml
<!-- NavigationView 样式定制 -->
<Style Selector="fa|NavigationViewItem">
    <Setter Property="Margin" Value="0,0"/>
    <Setter Property="Padding" Value="0,8"/>
    <Setter Property="MinHeight" Value="40"/>
</Style>

<!-- 选中状态样式 -->
<Style Selector="fa|NavigationViewItem:selected /template/ Border#LayoutRoot">
    <Setter Property="Background" Value="{DynamicResource SystemAccentColorLight2}"/>
</Style>

<!-- 悬停状态样式 -->
<Style Selector="fa|NavigationViewItem:pointerover /template/ Border#LayoutRoot">
    <Setter Property="Background" Value="{DynamicResource SystemAccentColorLight3}"/>
</Style>
```

**ContentDialog 使用规范**
```xml
<fa:ContentDialog Title="确认操作"
                  PrimaryButtonText="确认"
                  SecondaryButtonText="取消"
                  CloseButtonText="关闭"
                  DefaultButton="Primary"
                  IsPrimaryButtonEnabled="{Binding CanConfirm}">
    <StackPanel Spacing="12">
        <TextBlock Text="确定要执行此操作吗？" />
        <fa:InfoBar Severity="Warning"
                    Message="此操作不可撤销"
                    IsOpen="True" />
    </StackPanel>
</fa:ContentDialog>
```

**SettingsExpander 使用规范**
```xml
<fa:SettingsExpander Header="高级设置"
                     Description="配置高级选项"
                     IsExpanded="{Binding IsAdvancedExpanded}">
    <fa:SettingsExpander.Items>
        <fa:SettingsCard Header="选项1"
                         Description="第一个高级选项">
            <fa:ToggleSwitch IsOn="{Binding Option1}" />
        </fa:SettingsCard>
        <fa:SettingsCard Header="选项2"
                         Description="第二个高级选项">
            <fa:NumberBox Value="{Binding Option2Value}" />
        </fa:SettingsCard>
    </fa:SettingsExpander.Items>
</fa:SettingsExpander>
```

## 4. 服务架构规范

### 4.1 服务注册
使用 `ServiceLocator` 注册和管理服务：

```csharp
// 在应用启动时注册服务
ServiceLocator.Register<IMyService>(new MyService());

// 获取服务实例
var service = ServiceLocator.Get<IMyService>();
```

### 4.2 服务生命周期
- **单例服务**: 应用生命周期内保持唯一实例
- **瞬态服务**: 每次请求创建新实例
- **作用域服务**: 在特定作用域内保持单例

### 4.3 服务接口设计
```csharp
public interface IMyService
{
    // 方法定义
    Task<string> GetDataAsync();
    void ProcessData(string data);
}

public class MyService : IMyService
{
    public async Task<string> GetDataAsync()
    {
        // 实现逻辑
        return await Task.FromResult("data");
    }

    public void ProcessData(string data)
    {
        // 实现逻辑
    }
}
```

## 5. 数据层规范

### 5.1 数据模型定义
使用 sqlite-net-pcl 定义数据模型：

```csharp
[Table("Applications")]
public class ApplicationDB
{
    [PrimaryKey, AutoIncrement]
    public int Id { get; set; }

    [NotNull]
    public string Name { get; set; } = string.Empty;

    [NotNull]
    public string Path { get; set; } = string.Empty;

    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}
```

### 5.2 数据库操作
使用 `DBContext` 进行数据库操作：

```csharp
// 插入数据
await DBContext.Instance.InsertAsync(application);

// 查询数据
var applications = await DBContext.Instance.Table<ApplicationDB>().ToListAsync();

// 更新数据
await DBContext.Instance.UpdateAsync(application);

// 删除数据
await DBContext.Instance.DeleteAsync(application);
```

### 5.3 数据库迁移
数据库版本管理和迁移策略：
- 使用版本号标识数据库结构版本
- 在应用启动时检查并执行必要的迁移
- 提供回滚机制以应对迁移失败

## 6. 插件开发规范

### 6.1 插件项目结构
```
MyPlugin/
├── MyPlugin.csproj           # 项目文件
├── plugin.json              # 插件元数据
├── MyPlugin.cs              # 插件主类
└── Views/                   # 插件UI（可选）
```

### 6.2 插件元数据配置
在 `plugin.json` 中定义插件信息：

```json
{
  "name": "MyPlugin",
  "version": "1.0.0",
  "description": "My custom MicroDock plugin",
  "author": "Your Name",
  "dependencies": [],
  "minAppVersion": "1.0.0"
}
```

### 6.3 插件接口实现
```csharp
using MicroDock.Plugin;

public class MyPlugin : BaseMicroDockPlugin
{
    public override string Name => "MyPlugin";
    public override string Version => "1.0.0";
    public override string Description => "My custom MicroDock plugin";

    public override void Initialize()
    {
        // 插件初始化逻辑
    }

    public override void Shutdown()
    {
        // 插件清理逻辑
    }
}
```

### 6.4 插件开发最佳实践
- **资源管理**: 在 Shutdown 方法中正确释放资源
- **异常处理**: 捕获并记录插件内部异常
- **线程安全**: 避免在插件中执行阻塞操作
- **版本兼容**: 遵循语义化版本控制

## 7. 事件和通信规范

### 7.1 事件聚合器使用
使用 `EventAggregator` 进行模块间通信：

```csharp
// 发布事件
EventAggregator.Instance.Publish(new MyEvent { Data = "value" });

// 订阅事件
EventAggregator.Instance.Subscribe<MyEvent>(OnMyEvent);

// 事件处理
private void OnMyEvent(MyEvent evt)
{
    // 处理事件
}
```

### 7.2 事件消息定义
```csharp
public interface IEventMessage
{
}

public class MyEvent : IEventMessage
{
    public string Data { get; set; }
}
```

## 8. 异常处理和日志规范

### 8.1 异常处理原则
- **捕获特定异常**: 避免捕获过于宽泛的异常
- **记录详细信息**: 记录异常发生的上下文信息
- **用户友好提示**: 向用户显示友好的错误信息

### 8.2 日志记录规范
使用 Serilog 记录日志：

```csharp
// 记录不同级别的日志
Log.Information("操作成功完成");
Log.Warning("发现潜在问题：{Issue}", issue);
Log.Error(ex, "操作失败：{Operation}", operation);

// 结构化日志
Log.Information("用户 {UserId} 执行了 {Action}", userId, action);
```

### 8.3 日志级别使用
- **Information**: 正常操作流程
- **Warning**: 潜在问题，但不影响主要功能
- **Error**: 错误情况，影响功能使用
- **Debug**: 调试信息，仅在开发环境使用

## 9. 测试规范

### 9.1 单元测试
- **测试命名**: 使用 `MethodName_ExpectedBehavior` 格式
- **AAA 模式**: Arrange（准备）、Act（执行）、Assert（断言）
- **模拟依赖**: 使用模拟框架隔离依赖项

### 9.2 集成测试
- **端到端测试**: 测试完整的用户场景
- **数据库测试**: 使用内存数据库或测试数据库
- **插件测试**: 测试插件的加载和功能

### 9.3 UI 测试
- **控件测试**: 测试控件的交互和显示
- **导航测试**: 测试页面导航和数据传递
- **响应式测试**: 测试不同尺寸下的显示效果

## 10. 性能优化规范

### 10.1 UI 性能
- **虚拟化**: 对大列表使用虚拟化技术
- **数据绑定优化**: 避免复杂的绑定表达式
- **资源管理**: 及时释放图片和其他资源
- **FluentAvalonia 性能**: 合理使用 FluentAvalonia 控件避免过度渲染
- **控件懒加载**: 对于复杂的控件使用懒加载策略
- **样式缓存**: 避免在运行时频繁创建样式

### 10.4 FluentAvalonia 性能优化
- **NavigationView 优化**:
  - 限制菜单项数量，使用分组和虚拟化
  - 避免在选中项中使用复杂的布局
  - 使用 `CompactModeThresholdWidth` 合理设置紧凑模式阈值

- **ContentDialog 优化**:
  - 预定义常用的对话框样式
  - 避免在对话框中放置过多控件
  - 使用异步加载对话框内容

- **SettingsCard/SettingsExpander 优化**:
  - 避免嵌套过深的 SettingsExpander
  - 对于大量设置项使用虚拟化容器
  - 延迟加载复杂设置内容

- **动画和过渡效果**:
  - 使用 FluentAvalonia 内置动画而非自定义动画
  - 合理设置动画时长和缓动函数
  - 在低性能设备上可禁用部分动画效果

### 10.2 内存管理
- **IDisposable 实现**: 正确实现 Dispose 模式
- **弱引用**: 在缓存中使用弱引用避免内存泄漏
- **事件订阅取消**: 及时取消事件订阅

### 10.3 异步编程
- **async/await**: 使用异步编程模式避免 UI 阻塞
- **ConfigureAwait**: 在库代码中使用 `ConfigureAwait(false)`
- **取消令牌**: 支持长时间操作的可取消性

## 11. 安全规范

### 11.1 插件安全
- **插件验证**: 验证插件的来源和完整性
- **权限控制**: 限制插件访问系统资源的权限
- **沙箱执行**: 在受限环境中执行插件代码

### 11.2 数据安全
- **输入验证**: 验证用户输入的数据
- **敏感信息**: 避免在日志中记录敏感信息
- **数据加密**: 对敏感数据进行加密存储

## 12. 代码质量规范

### 12.1 代码审查
- **代码规范**: 遵循统一的编码规范
- **可读性**: 编写清晰、易读的代码
- **注释**: 为复杂逻辑添加必要的注释

### 12.3 UI 代码质量
- **FluentAvalonia 使用**: 优先使用 FluentAvalonia 控件，避免混合使用原生控件
- **XAML 结构**: 保持 XAML 文件结构清晰，适当使用注释
- **命名空间管理**: 正确引入 FluentAvalonia 命名空间，移除未使用的引用
- **样式一致性**: 确保整个应用的视觉风格统一
- **响应式设计**: 测试不同窗口尺寸下的显示效果
- **无障碍性**: 添加适当的 AutomationProperties 和辅助功能支持

### 12.4 XAML 代码规范
```xml
<!-- ✅ 好的 XAML 写法 -->
<fa:SettingsCard Header="应用设置"
                 Description="配置应用程序的基本选项"
                 IsEnabled="{Binding IsSettingsEnabled}"
                 AutomationProperties.Name="应用设置卡片">
    <StackPanel Spacing="8">
        <fa:ToggleSwitch IsOn="{Binding AutoStart}"
                         Header="开机自启"
                         AutomationProperties.HelpText="启用开机自动启动应用" />
        <fa:NumberBox Value="{Binding IconSize}"
                      Header="图标大小"
                      Minimum="32"
                      Maximum="128"
                      AutomationProperties.HelpText="设置应用图标大小" />
    </StackPanel>
</fa:SettingsCard>

<!-- ❌ 避免的写法 -->
<StackPanel>
    <TextBlock Text="应用设置"/>
    <CheckBox IsChecked="{Binding AutoStart}"/>
    <TextBox Text="{Binding IconSize}"/>
</StackPanel>
```

### 12.2 代码分析工具
- **静态分析**: 使用代码分析工具检查代码质量
- **代码格式化**: 使用统一的代码格式化规则
- **依赖分析**: 定期检查和更新依赖包

## 13. 版本控制和发布规范

### 13.1 分支策略
- **main**: 主分支，保持稳定可发布状态
- **develop**: 开发分支，集成最新功能
- **feature**: 功能分支，开发特定功能
- **hotfix**: 热修复分支，修复紧急问题

### 13.2 提交规范
- **提交信息**: 使用清晰的提交信息描述变更
- **原子提交**: 每次提交包含一个完整的逻辑变更
- **代码审查**: 重要变更需要经过代码审查

### 13.3 版本发布
- **语义化版本**: 遵循 SemVer 版本规范
- **发布说明**: 提供详细的版本发布说明
- **向后兼容**: 保持 API 的向后兼容性

## 14. 文档规范

### 14.1 代码文档
- **XML 注释**: 为公共 API 添加 XML 注释
- **README**: 提供项目说明和使用指南
- **CHANGELOG**: 维护版本变更记录

### 14.2 技术文档
- **架构文档**: 描述系统架构和设计决策
- **API 文档**: 提供完整的 API 参考文档
- **部署文档**: 说明部署和配置方法

## 变更记录

- **2025-11-17 v1.1**:
  - 新增 FluentAvalonia 控件使用原则和规范
  - 增加 UI 设计原则章节
  - 完善 XAML 代码规范和质量要求
  - 添加 FluentAvalonia 性能优化指南
  - 增强无障碍性支持要求

- **2025-11-17 v1.0**:
  - 创建基础项目开发规范文档
  - 涵盖 14 个主要开发规范领域

---

**版本**: 1.1
**最后更新**: 2025-11-17
**维护者**: MicroDock 开发团队