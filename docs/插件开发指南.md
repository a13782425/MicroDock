# MicroDock 插件开发指南

## 版本信息
- **文档版本**: 3.2.0
- **最后更新**: 2025-11-14
- **适用 MicroDock 版本**: 0.0.3.0+

## 目录
- [概述](#概述)
- [plugin.json 配置文件](#pluginjson-配置文件) ⭐ **重要更新**
- [快速开始](#快速开始)
- [插件接口](#插件接口)
- [插件工具系统](#插件工具系统) 🆕 **全新功能**
- [UI 页签开发规范](#ui-页签开发规范)
- [插件上下文 API](#插件上下文-api) 🆕 **新增章节**
  - [日志系统](#-日志系统)
  - [数据存储](#-数据存储)
  - [设置管理](#️-设置管理)
  - [依赖访问](#-依赖访问)
  - [图片管理](#️-图片管理)
  - [路径管理](#-路径管理)
  - [通知系统](#-通知系统)
  - [Loading 指示器](#-loading-指示器)
  - [托盘菜单](#-托盘菜单)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

---

## 概述

MicroDock 提供了一个灵活的插件系统，允许第三方开发者扩展应用功能。插件可以：
- 添加新的 UI 标签页
- 提供自定义操作和服务
- 集成外部工具和服务

### 技术栈
- **.NET 8.0**: 插件必须基于 .NET 8.0 开发
- **Avalonia UI**: 用于创建跨平台 UI 组件
- **MicroDock.Plugin**: 核心插件框架库

---

## plugin.json 配置文件

### ⭐ 重要更新（v0.0.2.0+）

从 MicroDock v0.0.2.0 开始，**所有插件必须提供 `plugin.json` 配置文件**。这个文件用于定义插件的元数据，插件接口不再需要实现元数据相关的属性。

### 为什么要使用 plugin.json？

- **元数据与代码分离**: 插件元数据不再耦合在代码中，更易于管理和修改
- **无需实例化即可读取**: 框架无需实例化插件类即可获取元数据，提升性能
- **依赖管理**: 支持声明式的依赖关系和版本范围
- **标准化**: 参考 npm 的 package.json，采用业界标准命名规范

### 完整配置示例

```json
{
  "name": "com.company.pluginname",
  "displayName": "插件显示名称",
  "version": "1.0.0",
  "description": "插件的详细描述",
  "author": "作者姓名 <email@example.com>",
  "license": "MIT",
  "homepage": "https://github.com/user/plugin",
  
  "main": "PluginName.dll",
  "entryClass": "Namespace.PluginClassName",
  
  "dependencies": {
    "com.other.plugin": "^2.0.0"
  },
  
  "engines": "0.0.1.0"
}
```

### 字段详细说明

#### 必需字段

| 字段 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `name` | string | **插件唯一标识符**，使用反向域名格式 | `"com.example.testplugin"` |
| `version` | string | **语义化版本号** (Semver格式) | `"1.0.0"` |
| `main` | string | **主 DLL 文件名** | `"TestPlugin.dll"` |
| `entryClass` | string | **入口类的完全限定名** | `"Test.TestPlugin"` |

#### 可选字段

| 字段 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `displayName` | string | 显示给用户的友好名称，默认为 `name` | `"测试插件"` |
| `description` | string | 插件的详细描述 | `"这是一个测试插件"` |
| `author` | string | 作者信息 | `"John Doe <john@example.com>"` |
| `license` | string | 开源许可证 | `"MIT"` |
| `homepage` | string | 插件主页 URL | `"https://github.com/..."` |
| `dependencies` | object | 插件依赖（键为插件名，值为版本范围） | `{"com.other.plugin": "^1.0.0"}` |
| `engine` | string | 运行环境最低要求 | `"1.0.0.0"` |

### name 字段命名规范

**格式**: `com.company.pluginname`

**规则**:
- 使用反向域名格式（类似 Java 包名）
- 只能包含小写字母、数字、点 `.` 和连字符 `-`
- 每个部分必须以字母开头
- 至少包含两个部分（用点分隔）

**示例**:
- ✅ `com.microdock.test`
- ✅ `com.example.weather-plugin`
- ✅ `org.mycompany.tool`
- ❌ `TestPlugin` （不符合反向域名格式）
- ❌ `com.Example.Plugin` （包含大写字母）
- ❌ `com.123company.plugin` （数字开头）

### version 字段版本格式

**格式**: `主版本.次版本.补丁版本[-预发布版本][+构建元数据]`

**示例**:
- `1.0.0` - 正式版本
- `2.3.1` - 标准版本
- `1.0.0-alpha` - 预发布版本
- `1.0.0-beta.1` - 带序号的预发布版本
- `1.0.0+20231113` - 带构建元数据的版本

### dependencies 依赖管理

#### 版本范围语法

| 格式 | 说明 | 匹配示例 |
|------|------|----------|
| `1.0.0` | 精确版本 | 只匹配 `1.0.0` |
| `^1.0.0` | 兼容版本（主版本相同） | `1.0.0` ~ `1.x.x` |
| `~1.0.0` | 补丁版本（主次版本相同） | `1.0.0` ~ `1.0.x` |
| `>=1.0.0` | 最低版本 | `1.0.0` 及以上 |
| `*` | 任意版本 | 任何版本 |

#### 依赖示例

```json
{
  "dependencies": {
    "com.base.plugin": "^2.0.0",      // 兼容 2.x.x 版本
    "com.utils.plugin": "~1.5.0",     // 兼容 1.5.x 版本
    "com.required.plugin": ">=3.0.0", // 3.0.0 或更高版本
    "com.any.plugin": "*"              // 任意版本
  }
}
```

### 最小配置示例

一个最简单的 `plugin.json` 示例：

```json
{
  "name": "com.example.myplugin",
  "version": "1.0.0",
  "main": "MyPlugin.dll",
  "entryClass": "MyPlugin.MyPluginClass"
}
```

### 项目配置

在 `.csproj` 文件中配置自动复制 `plugin.json`：

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\MicroDock.Plugin\MicroDock.Plugin.csproj" />
  </ItemGroup>

  <!-- 自动复制 plugin.json 到输出目录 -->
  <ItemGroup>
    <None Update="plugin.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>
```

---

## 快速开始

### 1. 创建插件项目

```bash
# 创建新的类库项目
dotnet new classlib -n MyMicroDockPlugin -f net8.0

# 添加对 MicroDock.Plugin 的引用
cd MyMicroDockPlugin
dotnet add reference path/to/MicroDock.Plugin.csproj

# 添加 Avalonia UI 依赖（如果需要创建 UI）
dotnet add package Avalonia --version 11.3.8
```

### 2. 创建 plugin.json

在项目根目录创建 `plugin.json` 文件：

```json
{
  "name": "com.mycompany.myplugin",
  "displayName": "我的插件",
  "version": "1.0.0",
  "description": "这是一个示例插件",
  "author": "Your Name <your.email@example.com>",
  "license": "MIT",
  
  "main": "MyMicroDockPlugin.dll",
  "entryClass": "MyMicroDockPlugin.MyPlugin",
  
  "engines": "0.0.2.0"
}
```

### 3. 实现插件接口

创建主插件类并实现 `IMicroDockPlugin` 接口：

```csharp
using MicroDock.Plugin;

public class MyPlugin : BaseMicroDockPlugin
{
    // 插件生命周期方法
    public override void OnInit()
    {
        base.OnInit();
        // 插件初始化逻辑
        Context!.LogInfo("我的插件已初始化");
    }

    public override void OnEnable()
    {
        base.OnEnable();
        Context!.LogInfo("我的插件已启用");
    }

    public override void OnDisable()
    {
        base.OnDisable();
        Context!.LogInfo("我的插件已禁用");
    }

    public override void OnDestroy()
    {
        base.OnDestroy();
        // 插件清理逻辑
        Context!.LogInfo("我的插件正在销毁");
    }
    
    // 插件标签页配置
    public override IMicroTab[] Tabs => Array.Empty<IMicroTab>();
}
```

### 4. 添加标签页（可选）

如果您的插件需要提供 UI 界面，创建一个标签页视图并在 `Tabs` 属性中返回：

**MyTabView.axaml**:
```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="MyMicroDockPlugin.MyTabView">
    <StackPanel Margin="0,12,12,12" Spacing="8">
        <TextBlock Text="我的标签页" FontSize="16" FontWeight="Bold"/>
        <TextBox Watermark="输入内容..."/>
        <Button Content="提交"/>
    </StackPanel>
</UserControl>
```

**实现 IMicroTab 接口的 View 类**:
```csharp
// MyTabView.axaml.cs
using Avalonia.Controls;
using MicroDock.Plugin;

public partial class MyTabView : UserControl, IMicroTab
{
    public string TabName => "我的标签页";
    public IconSymbolEnum IconSymbol => IconSymbolEnum.GamesFilled;
    
    public MyTabView()
    {
        InitializeComponent();
    }
}
```

**更新插件类**:
```csharp
public class MyPlugin : BaseMicroDockPlugin
{
    private MyTabView? _tabView;
    
    public override IMicroTab[] Tabs
    {
        get
        {
            if (_tabView == null)
            {
                _tabView = new MyTabView();
            }
            return new IMicroTab[] { _tabView };
        }
    }
}
```

### 5. 配置项目文件

更新 `.csproj` 文件，确保 `plugin.json` 被复制到输出目录：

```xml
<ItemGroup>
  <None Update="plugin.json">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
</ItemGroup>
```

### 6. 编译和部署

```bash
# 编译插件
dotnet build -c Release

# 将生成的文件复制到 MicroDock 的 Plugins/PluginName 目录
# 注意：每个插件需要在独立的子文件夹中
mkdir -p path/to/MicroDock/Plugins/MyPlugin
cp bin/Release/net8.0/* path/to/MicroDock/Plugins/MyPlugin/
```

**重要**: 插件必须放在 `Plugins` 目录下的独立子文件夹中，文件夹名称建议与插件名称一致。

---

## 插件接口

### IMicroDockPlugin（核心接口）

所有插件必须实现的基础接口：

```csharp
public interface IMicroDockPlugin
{
    /// <summary>
    /// 初始化插件上下文（由框架调用，之后会调用 OnInit）
    /// </summary>
    void Initialize(IPluginContext context);

    /// <summary>
    /// 所有标签页
    /// </summary>
    IMicroTab[] Tabs { get; }

    /// <summary>
    /// 获取插件的设置UI控件（可选，返回null表示没有设置）
    /// </summary>
    object? GetSettingsControl();

    /// <summary>
    /// 插件初始化
    /// </summary>
    void OnInit();

    /// <summary>
    /// 异步初始化(可选)
    /// </summary>
    Task OnInitAsync();

    /// <summary>
    /// 所有插件初始化完成后调用
    /// </summary>
    void OnAllPluginsLoaded();

    /// <summary>
    /// 插件启用
    /// </summary>
    void OnEnable();

    /// <summary>
    /// 插件禁用
    /// </summary>
    void OnDisable();

    /// <summary>
    /// 插件释放
    /// </summary>
    void OnDestroy();
}
```

### IMicroTab（标签页接口）

用于向主应用添加新的标签页：

```csharp
public interface IMicroTab
{
    /// <summary>
    /// 页签名字
    /// </summary>
    string TabName { get; }
    
    /// <summary>
    /// 页签图标
    /// </summary>
    IconSymbolEnum IconSymbol { get; }
}
```

**重要说明**：
- 实现 `IMicroTab` 接口的类通常是一个 `UserControl`，该控件本身就是标签页的内容
- `IconSymbolEnum` 提供了大量预定义的图标符号（如 `GamesFilled`、`FolderFilled`、`Settings` 等）
- 完整的图标列表请参考 `MicroDock.Plugin.IconSymbolEnum` 枚举

---

## 插件工具系统

### 🆕 全新功能（v0.0.3.0+）

从 MicroDock v0.0.3.0 开始，插件系统引入了**工具调用系统**，允许插件之间通过工具名和参数相互调用功能，类似于 MCP (Model Context Protocol) 的设计理念。

### 工具系统特性

- ✅ **基于特性定义**: 使用 `[MicroTool]` 特性标记方法
- ✅ **强类型参数**: 支持基本类型、复杂对象、泛型等各种参数类型
- ✅ **自动类型转换**: 框架自动处理类型转换和 JSON 序列化
- ✅ **插件名限定**: 可指定调用特定插件的工具
- ✅ **工具发现 API**: 查询所有可用工具及其详细信息
- ✅ **完整文档**: 工具和参数的详细描述
- ✅ **异步执行**: 所有工具调用都是异步的
- ✅ **日志和统计**: 自动记录工具调用和使用统计

### 定义工具

#### 基本工具示例

```csharp
using MicroDock.Plugin;
using System.Threading.Tasks;

public class MyPlugin : BaseMicroDockPlugin
{
    /// <summary>
    /// 简单的字符串反转工具
    /// </summary>
    [MicroTool("string.reverse",
        Description = "反转输入的字符串",
        ReturnDescription = "反转后的字符串")]
    public async Task<string> ReverseString(
        [ToolParameter("input", Description = "要反转的字符串")] 
        string input)
    {
        await Task.CompletedTask;
        return new string(input.Reverse().ToArray());
    }
}
```

#### 复杂参数工具示例

```csharp
/// <summary>
/// 处理复杂数据对象
/// </summary>
[MicroTool("data.filter",
    Description = "过滤数据列表",
    ReturnDescription = "过滤后的数据 JSON")]
public async Task<string> FilterData(
    [ToolParameter("items", Description = "数据列表")] 
    List<MyDataModel> items,
    [ToolParameter("minValue", Description = "最小值", Required = false)] 
    int minValue = 0)
{
    await Task.CompletedTask;
    var filtered = items.Where(x => x.Value >= minValue).ToList();
    return System.Text.Json.JsonSerializer.Serialize(filtered);
}
```

### 工具特性详解

#### MicroToolAttribute

```csharp
[MicroTool("tool.name",
    Description = "工具的详细描述",
    ReturnDescription = "返回值的说明")]
```

- **name**: 工具的唯一标识符（建议使用 `category.action` 格式）
- **Description**: 工具功能的详细描述
- **ReturnDescription**: 返回值的说明

#### ToolParameterAttribute

```csharp
[ToolParameter("paramName",
    Description = "参数的详细描述",
    Required = true)]
```

- **name**: 参数名称
- **Description**: 参数的详细说明
- **Required**: 是否为必需参数（有默认值时自动为 false）

### 工具方法的类型

MicroDock 工具系统支持三种类型的工具方法，每种类型都有其特定的使用场景和性能特征：

#### 1. 静态方法工具 ⚡

**特点**:
- 无需实例，直接调用
- 性能最优，无实例创建开销
- 无法维护状态

**适用场景**:
- 无状态的纯函数工具
- 工具函数、计算、转换等操作
- 性能敏感的场景

**示例**:

```csharp
/// <summary>
/// 静态方法工具示例：格式化日期时间
/// </summary>
[MicroTool("test.static_format_date",
    Description = "静态方法：格式化当前日期时间",
    ReturnDescription = "格式化后的日期时间字符串")]
public static async Task<string> FormatCurrentDate(
    [ToolParameter("format", Description = "日期格式", Required = false)] 
    string format = "yyyy-MM-dd HH:mm:ss")
{
    await Task.CompletedTask;
    return DateTime.Now.ToString(format);
}
```

**优点**:
- ✅ 性能最优，无额外开销
- ✅ 线程安全（无状态）
- ✅ 简单直观

**限制**:
- ❌ 无法访问插件实例的状态
- ❌ 无法使用插件的上下文和服务

#### 2. 插件类实例方法工具 🔌

**特点**:
- 使用插件已有实例
- 性能优，无额外开销
- 可以访问插件状态和资源

**适用场景**:
- 需要访问插件状态或配置
- 需要使用插件上下文服务
- 与插件功能紧密耦合的操作

**示例**:

```csharp
public class MyPlugin : BaseMicroDockPlugin
{
    private int _pluginState = 0;

    [MicroTool("plugin.instance_tool",
        Description = "插件实例方法示例",
        ReturnDescription = "处理结果")]
    public async Task<string> InstanceTool(
        [ToolParameter("param", Description = "参数")] string param)
    {
        // 可以访问插件实例的字段和属性
        _pluginState++;
        Context!.LogInfo($"处理参数: {param}, 状态: {_pluginState}");
        
        // 可以使用插件上下文
        var config = GetSettings("config_key");
        
        return await Task.FromResult($"处理完成: {param}");
    }
}
```

**优点**:
- ✅ 无额外实例创建开销
- ✅ 可以访问插件状态和配置
- ✅ 可以使用插件上下文服务

**限制**:
- ❌ 仅限于插件类本身的方法

#### 3. 其他类实例方法工具 ⚠️

**特点**:
- 首次调用时创建实例，后续复用
- 性能：首次调用有创建开销，后续正常
- 可以维护工具的独立状态
- **UI 标识**: 设置界面中显示黄色警告框 "⚠️ 首次调用创建实例，后续复用"

**适用场景**:
- 需要状态管理的辅助工具
- 工具逻辑与插件主类解耦
- 需要复杂状态维护的工具集

**示例**:

```csharp
/// <summary>
/// 辅助类工具示例（演示实例复用和状态管理）
/// </summary>
internal class TestHelper
{
    private int _callCount = 0;
    private readonly List<string> _history = new();

    /// <summary>
    /// 工具：获取调用次数（演示实例复用）
    /// </summary>
    [MicroTool("test.helper_count",
        Description = "返回此工具实例的调用次数（演示实例复用）",
        ReturnDescription = "调用次数")]
    public async Task<string> GetCallCount()
    {
        await Task.CompletedTask;
        _callCount++;
        return $"此实例已被调用 {_callCount} 次";
    }

    /// <summary>
    /// 工具：记录操作历史
    /// </summary>
    [MicroTool("test.helper_reverse",
        Description = "反转字符串并记录历史",
        ReturnDescription = "反转后的字符串")]
    public async Task<string> ReverseString(
        [ToolParameter("text", Description = "要反转的字符串")] string text)
    {
        await Task.CompletedTask;
        var reversed = new string(text.Reverse().ToArray());
        _history.Add($"反转: {text} -> {reversed}");
        return reversed;
    }

    /// <summary>
    /// 工具：获取操作历史
    /// </summary>
    [MicroTool("test.helper_history",
        Description = "获取所有操作历史",
        ReturnDescription = "历史记录（JSON 数组）")]
    public async Task<string> GetHistory()
    {
        await Task.CompletedTask;
        return System.Text.Json.JsonSerializer.Serialize(_history);
    }
}
```

**优点**:
- ✅ 实例复用，避免重复创建
- ✅ 可以维护工具的独立状态
- ✅ 工具逻辑解耦，易于组织

**限制**:
- ❌ 首次调用有创建开销
- ⚠️ 需要有无参构造函数（可以是 private 或 internal）
- ⚠️ 实例在整个应用生命周期内存在，注意状态累积

**注意事项**:
1. **构造函数要求**: 非插件类必须有无参构造函数（可以是 private 或 internal）
2. **线程安全**: 实例创建是线程安全的，但工具方法本身需要自行保证线程安全
3. **状态管理**: 实例在整个应用生命周期内复用，注意状态累积和内存使用
4. **UI 提示**: 设置界面会自动显示黄色警告标识此类工具

#### 性能对比

| 工具类型 | 首次调用 | 后续调用 | 状态维护 | 适用场景 |
|---------|---------|---------|---------|---------|
| 静态方法 | ⚡ 最快 | ⚡ 最快 | ❌ 不支持 | 无状态纯函数 |
| 插件实例方法 | ⚡ 快 | ⚡ 快 | ✅ 插件状态 | 与插件耦合的操作 |
| 其他类实例方法 | 🐢 稍慢 | ⚡ 快 | ✅ 独立状态 | 需要状态的辅助工具 |

#### 选择建议

1. **优先使用静态方法**，除非需要状态管理
2. **需要插件状态时使用插件实例方法**
3. **需要独立状态管理时使用其他类实例方法**
4. **性能敏感场景优先选择静态方法**

### 调用工具

#### 在 OnAllPluginsLoaded 中调用

```csharp
public override void OnAllPluginsLoaded()
{
    base.OnAllPluginsLoaded();
    
    // 等所有插件加载完成后才能安全地调用其他插件的工具
    
    // 1. 调用全局工具（调用第一个匹配的）
    var result1 = await CallToolAsync("string.reverse", new Dictionary<string, string>
    {
        ["input"] = "Hello World"
    });
    
    // 2. 指定插件名调用
    var result2 = await CallToolAsync("math.add", new Dictionary<string, string>
    {
        ["a"] = "10",
        ["b"] = "20"
    }, pluginName: "com.microdock.test");
    
    // 3. 复杂对象参数（需要序列化为 JSON 字符串）
    var items = new List<MyDataModel> { /* ... */ };
    var itemsJson = System.Text.Json.JsonSerializer.Serialize(items);
    var result3 = await CallToolAsync("data.filter", new Dictionary<string, string>
    {
        ["items"] = itemsJson,  // 复杂对象需要先序列化为 JSON 字符串
        ["minValue"] = "10"
    });
}
```

### 工具发现

```csharp
public override void OnAllPluginsLoaded()
{
    base.OnAllPluginsLoaded();
    
    // 获取所有可用工具
    var allTools = GetAvailableTools();
    foreach (var tool in allTools)
    {
        Context!.LogInfo($"工具: {tool.Name}");
        Context!.LogInfo($"  描述: {tool.Description}");
        Context!.LogInfo($"  提供者: {tool.ProviderPlugin}");
        Context!.LogInfo($"  参数: {tool.ParametersSummary}");
    }
    
    // 获取指定插件的工具
    var pluginTools = GetPluginTools("com.microdock.test");
    
    // 获取工具详细信息
    var toolInfo = GetToolInfo("string.reverse");
    if (toolInfo != null)
    {
        Context!.LogInfo($"返回值: {toolInfo.ReturnDescription}");
        foreach (var param in toolInfo.Parameters)
        {
            Context!.LogInfo($"  参数: {param.Name} ({param.TypeName})");
            Context!.LogInfo($"    描述: {param.Description}");
            Context!.LogInfo($"    必需: {param.Required}");
        }
    }
}
```

### 支持的参数类型

工具方法可以接受以下类型的参数（调用时都以字符串形式传递，框架自动转换）：

#### 基本类型
```csharp
int, string, bool, double, float, long, decimal, byte, short, char
```

**调用示例**：
```csharp
new Dictionary<string, string>
{
    ["age"] = "25",           // int
    ["name"] = "John",        // string
    ["active"] = "true",      // bool
    ["price"] = "19.99"       // double
}
```

#### 可空类型
```csharp
int?, string?, bool?, double? 等
```

**调用示例**：
```csharp
new Dictionary<string, string>
{
    ["optionalAge"] = "25",   // int? (有值)
    ["optionalName"] = "",    // string? (空字符串表示 null)
}
```

#### 集合类型
```csharp
List<T>, Dictionary<TKey, TValue>, T[]
```

**调用示例**：
```csharp
var items = new List<string> { "item1", "item2", "item3" };
var itemsJson = System.Text.Json.JsonSerializer.Serialize(items);

new Dictionary<string, string>
{
    ["items"] = itemsJson  // 需要序列化为 JSON
}
```

#### 复杂类型
任何可 JSON 序列化的类型：

```csharp
public class MyDataModel
{
    public string Name { get; set; }
    public int Value { get; set; }
}
```

**调用示例**：
```csharp
var data = new MyDataModel { Name = "Test", Value = 100 };
var dataJson = System.Text.Json.JsonSerializer.Serialize(data);

new Dictionary<string, string>
{
    ["data"] = dataJson  // 需要序列化为 JSON
}
```

### 类型转换机制

框架会自动处理参数类型转换。由于 `CallToolAsync` 接受 `Dictionary<string, string>` 参数，所以：

1. **字符串参数**: 直接传递
2. **基本类型**: 框架会自动从字符串转换（如 `"42"` → `42`）
3. **复杂类型**: 需要先序列化为 JSON 字符串，框架会自动反序列化

```csharp
// 调用示例：
await CallToolAsync("tool.name", new Dictionary<string, string>
{
    ["intParam"] = "42",              // string -> int (框架自动转换)
    ["stringParam"] = "hello",         // string -> string (直接)
    ["boolParam"] = "true",            // string -> bool (框架自动转换)
    ["complexParam"] = JsonSerializer.Serialize(myObject)  // object -> JSON string -> object (框架反序列化)
});
```

**转换规则**：
- 基本类型（int、bool、double 等）：框架使用 `Convert.ChangeType` 从字符串转换
- 复杂类型（类、列表、字典等）：框架使用 JSON 反序列化
- 可空类型：支持 `null` 字符串或空字符串

### 工具命名规范

建议使用 **分类.操作** 的命名格式：

```csharp
[MicroTool("http.get")]      // HTTP GET 请求
[MicroTool("http.post")]     // HTTP POST 请求
[MicroTool("file.read")]     // 文件读取
[MicroTool("file.write")]    // 文件写入
[MicroTool("string.format")] // 字符串格式化
[MicroTool("math.calculate")] // 数学计算
```

### 错误处理

工具调用可能抛出以下异常：

```csharp
try
{
    var result = await CallToolAsync("tool.name", parameters);
}
catch (ToolNotFoundException ex)
{
    // 工具未找到
    Context!.LogError($"工具 {ex.ToolName} 未找到", ex);
}
catch (ToolParameterException ex)
{
    // 参数错误（缺失、类型不匹配等）
    Context!.LogError($"参数 {ex.ParameterName} 错误", ex);
}
catch (ToolExecutionException ex)
{
    // 工具执行失败
    Context!.LogError($"工具执行失败", ex);
}
```

### UI 展示

在设置界面的"插件管理"部分，会自动显示每个插件注册的工具：

- **工具列表**: 显示所有注册的工具名称
- **悬浮提示**: 鼠标悬停显示详细信息：
  - 工具描述
  - 返回值说明
  - 参数列表和描述
  - 参数类型和是否可选

### 最佳实践

1. **工具设计**: 
   - 保持工具功能单一和明确
   - 使用清晰的命名和详细的描述
   - 返回值统一为 JSON 字符串

2. **参数设计**:
   - 优先使用基本类型，减少序列化开销
   - 为可选参数提供合理的默认值
   - 使用 `Required = false` 明确标记可选参数

3. **异步编程**:
   - 所有工具方法必须是 `async Task<string>`
   - 避免在工具方法中阻塞线程
   - 适当使用 `ConfigureAwait(false)`

4. **错误处理**:
   - 捕获并记录工具内部的异常
   - 返回有意义的错误信息（JSON 格式）
   - 不要让异常传播到框架层

### 工具示例集合

查看 `Test` 插件中的完整示例：
- `test.reverse`: 字符串反转
- `test.add`: 整数相加
- `test.greet`: 格式化问候语（可选参数）
- `test.processData`: 处理复杂对象列表

---

## UI 页签开发规范

### ⚠️ 重要：ScrollViewer 使用规范

**从 MicroDock v0.0.1.0 开始，主应用已在 NavigationView 层面统一处理滚动功能。**

#### ✅ 正确做法

**不要在插件页签的最外层添加 ScrollViewer**。主应用会自动提供滚动支持。

```xml
<!-- ✅ 正确：直接使用布局容器作为根元素 -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="MyPlugin.MyTabView">
    <StackPanel Margin="10" Spacing="8">
        <TextBlock Text="标题"/>
        <TextBox Watermark="输入内容"/>
        <Button Content="提交"/>
        <!-- 更多内容... -->
    </StackPanel>
</UserControl>
```

#### ❌ 错误做法

```xml
<!-- ❌ 错误：不要在最外层添加 ScrollViewer -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="MyPlugin.MyTabView">
    <ScrollViewer VerticalScrollBarVisibility="Auto">
        <StackPanel Margin="10" Spacing="8">
            <!-- 内容... -->
        </StackPanel>
    </ScrollViewer>
</UserControl>
```

#### 📋 局部滚动区域

如果您的插件需要在**特定区域**内实现独立滚动（例如列表、文本框等），可以在该区域使用 ScrollViewer：

```xml
<UserControl>
    <Grid RowDefinitions="Auto,*,Auto">
        <!-- 固定的头部区域 -->
        <StackPanel Grid.Row="0">
            <TextBlock Text="固定头部"/>
        </StackPanel>
        
        <!-- 可滚动的内容区域 -->
        <ScrollViewer Grid.Row="1" 
                      VerticalScrollBarVisibility="Auto">
            <ListBox ItemsSource="{Binding Items}"/>
        </ScrollViewer>
        
        <!-- 固定的底部区域 -->
        <StackPanel Grid.Row="2">
            <Button Content="提交"/>
        </StackPanel>
    </Grid>
</UserControl>
```

### UI 布局建议

#### 推荐的根容器

根据您的布局需求选择合适的容器：

1. **StackPanel**: 简单的垂直/水平堆叠布局
2. **Grid**: 复杂的网格布局
3. **DockPanel**: 停靠式布局
4. **Panel**: 自定义布局

#### 边距和间距

为了保持与主应用的一致性，建议：

```xml
<StackPanel Margin="0,12,12,12" Spacing="8">
    <!-- 内容 -->
</StackPanel>
```

- **Margin**: `0,12,12,12` (左、上、右、下)
- **Spacing**: `8` 像素（元素间距）

#### ⚠️ 窗口最小尺寸要求

**MicroDock 主窗口的最小尺寸为 360×360 像素**，插件开发者应确保 UI 布局能够适配此最小尺寸。

##### 布局适配建议

1. **使用响应式布局**
   - 优先使用 `Grid` 和 `*` 尺寸单位，让内容自适应可用空间
   - 避免固定宽度的元素，使用 `MinWidth` 和 `MaxWidth` 限制范围

2. **内容可滚动**
   - 虽然主应用提供了统一的滚动支持，但插件内容应设计为在小尺寸下也能正常显示
   - 重要内容应优先显示在可见区域内

3. **控件尺寸控制**
   ```xml
   <!-- ✅ 推荐：使用最小/最大尺寸限制 -->
   <TextBox MinWidth="200" MaxWidth="400"/>
   
   <!-- ❌ 避免：固定宽度 -->
   <TextBox Width="400"/>
   ```

4. **布局示例**
   ```xml
   <UserControl>
       <Grid RowDefinitions="Auto,*,Auto">
           <!-- 固定高度的头部 -->
           <StackPanel Grid.Row="0" Margin="0,12,12,12">
               <TextBlock Text="标题" FontSize="16" FontWeight="Bold"/>
           </StackPanel>
           
           <!-- 自适应高度的内容区域 -->
           <StackPanel Grid.Row="1" Margin="0,0,12,12" Spacing="8">
               <!-- 内容会自动适应可用空间 -->
               <TextBox Watermark="输入内容..." MinHeight="100"/>
               <ListBox ItemsSource="{Binding Items}" MinHeight="150"/>
           </StackPanel>
           
           <!-- 固定高度的底部操作区 -->
           <StackPanel Grid.Row="2" Orientation="Horizontal" 
                      HorizontalAlignment="Right" Margin="0,0,12,12">
               <Button Content="取消" Margin="0,0,8,0"/>
               <Button Content="确定"/>
           </StackPanel>
       </Grid>
   </UserControl>
   ```

5. **测试建议**
   - 在开发时，将窗口调整为最小尺寸（360×360）测试布局效果
   - 确保所有重要功能和内容在小尺寸下都能正常访问
   - 检查文本是否被截断，控件是否重叠

### Avalonia 控件使用

#### FluentAvaloniaUI 组件

推荐使用 FluentAvaloniaUI 组件以保持 UI 风格一致：

```xml
<UserControl xmlns:fa="clr-namespace:FluentAvalonia.UI.Controls;assembly=FluentAvalonia">
    <StackPanel>
        <!-- 可折叠的设置面板 -->
        <fa:SettingsExpander Header="设置项" IconSource="Setting">
            <StackPanel>
                <!-- 设置内容 -->
            </StackPanel>
        </fa:SettingsExpander>
    </StackPanel>
</UserControl>
```

#### 常用控件示例

```xml
<!-- 文本输入 -->
<TextBox Watermark="请输入..." 
         AcceptsReturn="True"
         MinHeight="100"/>

<!-- 按钮 -->
<Button Content="操作" 
        Padding="20,8"
        Command="{Binding MyCommand}"/>

<!-- 开关 -->
<ToggleSwitch IsChecked="{Binding IsEnabled}"
              OnContent="开启"
              OffContent="关闭"/>

<!-- 下拉框 -->
<ComboBox ItemsSource="{Binding Options}"
          SelectedItem="{Binding SelectedOption}"/>
```

---

## 插件上下文 API

### 📝 日志系统

MicroDock 提供了完整的日志系统，插件可以通过 `Context` 属性访问日志方法。所有日志都会自动添加插件名称前缀，方便在日志查看器中识别和过滤。

#### 日志级别

插件支持四种日志级别：

1. **Debug（调试）**: 详细的调试信息，通常只在开发时使用
2. **Info（信息）**: 一般性的信息记录，用于记录正常操作流程
3. **Warning（警告）**: 警告信息，表示可能存在问题但不影响功能
4. **Error（错误）**: 错误信息，表示发生了错误，可以包含异常对象

#### 日志方法

日志方法通过 `Context` 属性访问：

```csharp
public class MyPlugin : BaseMicroDockPlugin
{
    public override void OnInit()
    {
        base.OnInit();
        
        // 调试日志 - 用于开发调试
        Context!.LogDebug("插件初始化开始");
        
        // 信息日志 - 记录正常操作
        Context!.LogInfo("插件已成功初始化");
        
        // 警告日志 - 记录潜在问题
        if (someCondition)
        {
            Context!.LogWarning("检测到潜在问题，但继续执行");
        }
        
        // 错误日志 - 记录错误和异常
        try
        {
            // 可能抛出异常的操作
            DoSomething();
        }
        catch (Exception ex)
        {
            Context!.LogError("操作失败", ex);  // 包含异常对象
        }
    }
}
```

**注意**: `Context` 是 `public` 属性，可以直接访问。使用 `!` 空值抑制操作符是因为框架保证在插件生命周期方法中 `Context` 已初始化。

#### 日志使用示例

**基本使用**:
```csharp
// 记录信息日志
Context!.LogInfo("用户点击了按钮");

// 记录警告日志
Context!.LogWarning("配置文件不存在，使用默认配置");

// 记录错误日志（无异常）
Context!.LogError("无法连接到服务器");

// 记录错误日志（包含异常）
try
{
    ProcessData();
}
catch (Exception ex)
{
    Context!.LogError("数据处理失败", ex);
}
```

**在工具方法中使用**:
```csharp
[MicroTool("example.process",
    Description = "处理数据示例",
    ReturnDescription = "处理结果")]
public async Task<string> ProcessData(
    [ToolParameter("data", Description = "要处理的数据")] string data)
{
    Context!.LogInfo($"开始处理数据: {data}");
    
    try
    {
        // 处理逻辑
        var result = await ProcessAsync(data);
        Context!.LogInfo($"数据处理完成: {result}");
        return result;
    }
    catch (Exception ex)
    {
        Context!.LogError($"数据处理失败: {data}", ex);
        throw;  // 重新抛出异常，让框架处理
    }
}
```

**在异步操作中使用**:
```csharp
public async Task LoadDataAsync()
{
    Context!.LogDebug("开始加载数据");
    
    try
    {
        var data = await FetchDataFromApi();
        Context!.LogInfo($"成功加载 {data.Count} 条记录");
        return data;
    }
    catch (HttpRequestException ex)
    {
        Context!.LogError("网络请求失败", ex);
        throw;
    }
    catch (Exception ex)
    {
        Context!.LogError("未知错误", ex);
        throw;
    }
}
```

#### 日志查看

所有插件日志都会：
- **自动添加插件名称前缀**: 格式为 `[Plugin:插件名称]`
- **记录到日志文件**: 可以在主应用的"日志查看器"标签页中查看
- **支持日志级别筛选**: 在日志查看器中可以按级别过滤
- **支持关键字搜索**: 可以搜索特定插件的日志

#### 日志最佳实践

1. **合理使用日志级别**:
   - `Debug`: 仅在开发调试时使用，生产环境可能不输出
   - `Info`: 记录重要的操作和状态变化
   - `Warning`: 记录可能的问题，但不影响功能
   - `Error`: 记录错误和异常，必须包含足够的上下文信息

2. **提供有意义的日志消息**:
   ```csharp
   // ❌ 不好的日志
   Context!.LogInfo("处理完成");
   
   // ✅ 好的日志
   Context!.LogInfo($"数据处理完成，共处理 {count} 条记录，耗时 {duration}ms");
   ```

3. **在关键操作点记录日志**:
   ```csharp
   public override void OnInit()
   {
       Context!.LogInfo("插件初始化开始");
       // ... 初始化逻辑 ...
       Context!.LogInfo("插件初始化完成");
   }
   
   public override void OnDestroy()
   {
       Context!.LogInfo("插件开始销毁");
       // ... 清理逻辑 ...
       Context!.LogInfo("插件销毁完成");
   }
   ```

4. **错误日志应包含异常对象**:
   ```csharp
   // ✅ 正确：包含异常对象
   catch (Exception ex)
   {
       Context!.LogError("操作失败", ex);
   }
   
   // ⚠️ 不推荐：只记录消息
   catch (Exception ex)
   {
       Context!.LogError($"操作失败: {ex.Message}");
   }
   ```

5. **避免在循环中记录过多日志**:
   ```csharp
   // ❌ 不推荐：在循环中记录每条记录
   foreach (var item in items)
   {
       Context!.LogInfo($"处理项: {item}");  // 可能产生大量日志
   }
   
   // ✅ 推荐：记录汇总信息
   Context!.LogInfo($"开始处理 {items.Count} 项");
   foreach (var item in items)
   {
       ProcessItem(item);
   }
   Context!.LogInfo($"处理完成，共处理 {items.Count} 项");
   ```

### 💾 数据存储

插件可以使用键值存储 API 来保存和读取数据：

```csharp
// 保存数据
SetValue("user_preference", "dark_mode");

// 读取数据
var preference = GetValue("user_preference");

// 删除数据
DeleteValue("user_preference");

// 获取所有键
var allKeys = GetAllKeys();
```

**使用场景**:
- 保存用户偏好设置
- 缓存临时数据
- 存储插件状态

### ⚙️ 设置管理

插件可以使用设置 API 来管理配置，这些设置会在主应用的设置界面中显示：

```csharp
// 设置配置（带描述）
SetSettings("api_key", "your-api-key", "API 密钥，用于访问外部服务");

// 读取配置
var apiKey = GetSettings("api_key");

// 删除配置
DeleteSettings("api_key");

// 获取所有配置键
var settingsKeys = GetAllSettingsKeys();
```

**与键值存储的区别**:
- **设置 (Settings)**: 用于用户可配置的选项，会在设置界面显示
- **键值存储 (Values)**: 用于内部数据存储，不在设置界面显示

### 🔗 依赖访问

如果插件声明了依赖关系，可以访问依赖插件的设置和键值（只读）：

```csharp
// 从依赖插件读取键值
var value = GetValueFromDependency("com.other.plugin", "shared_data");

// 从依赖插件读取设置
var setting = GetSettingsFromDependency("com.other.plugin", "api_url");

// 获取依赖插件的所有键
var keys = GetKeysFromDependency("com.other.plugin");
```

**注意事项**:
- 只能读取，不能修改依赖插件的数据
- 需要先在 `plugin.json` 中声明依赖关系
- 建议在 `OnAllPluginsLoaded()` 中访问，确保依赖插件已加载

### 🖼️ 图片管理

插件可以保存和加载图片数据：

```csharp
// 保存图片
byte[] imageData = File.ReadAllBytes("icon.png");
SaveImage("my_icon", imageData);

// 加载图片
byte[]? loadedImage = LoadImage("my_icon");

// 删除图片
DeleteImage("my_icon");
```

**使用场景**:
- 缓存网络图片
- 保存用户上传的图片
- 存储插件图标

### 📁 路径管理

插件可以获取专用的目录路径：

```csharp
// 获取插件配置目录
string configPath = GetConfigPath();
// 例如: C:\Users\...\Plugins\MyPlugin\config

// 获取插件数据目录
string dataPath = GetPluginDataPath();
// 例如: C:\Users\...\Plugins\MyPlugin\data

// 获取插件数据目录
string tempDataPath = GetPluginTempDataPath();
// 例如: C:\Users\...\Plugins\MyPlugin\temp_data
```

#### ⚠️ 重要：Config , Data 和 TempData 目录的区别

在插件开发中，Config , Data 和 TempData 目录有不同的用途和生命周期：

##### Config 目录 - 插件配置（随版本更新）

- **用途**: 存储插件自身的配置文件、默认设置、预设模板等
- **特点**: 
  - 随插件版本更新而更新
  - **插件更新时会被删除并替换为新版本的 Config**
  - 不应存储用户个性化数据
- **示例**:
  - 插件的默认配置模板
  - 预设的工作流配置
  - 插件内置的资源文件引用

```csharp
// ❌ 错误：不要在 Config 中存储用户数据
string userPreference = File.ReadAllText(Path.Combine(Context.ConfigPath, "user_settings.json"));

// ✅ 正确：Config 用于插件默认配置
string defaultTemplate = File.ReadAllText(Path.Combine(Context.ConfigPath, "default_template.json"));
```

##### Data 目录 - 用户数据（永久保留,且会备份至服务器）

- **用途**: 存储用户创建、编辑的数据和个性化设置
- **特点**:
  - **插件更新时会被保留**
  - 存储用户的个性化数据
  - 跨版本持久化
- **示例**:
  - 用户创建的项目文件
  - 用户的个性化设置
  - 用户上传的资源文件
  - 应用状态和历史记录

```csharp
// ✅ 正确：用户数据存储在 Data 目录
string userProjects = Path.Combine(Context.DataPath, "projects");
Directory.CreateDirectory(userProjects);
File.WriteAllText(Path.Combine(userProjects, "my_project.json"), projectData);
```

##### TempData 目录 - 临时数据（不会备份至服务器）

- **用途**: 存储临时缓存、运行时生成的文件和不需要备份的数据
- **特点**:
  - **插件更新时会被保留**
  - **不会备份至服务器**，丢失后不影响核心功能
  - 适合存储可重新生成或下载的数据
  - 可用于大文件缓存，避免占用备份空间
- **示例**:
  - 网络请求的缓存数据
  - 图片/视频的临时缩略图
  - 日志文件和调试信息
  - 下载的临时文件
  - 运行时生成的中间文件

```csharp
// ✅ 正确：临时缓存存储在 TempData 目录
string cacheDir = Path.Combine(Context.TempDataPath, "cache");
Directory.CreateDirectory(cacheDir);

// 缓存网络请求结果
File.WriteAllText(Path.Combine(cacheDir, "api_response.json"), responseJson);

// 存储临时缩略图
File.WriteAllBytes(Path.Combine(cacheDir, "thumbnail.png"), thumbnailBytes);// ... existing code ...
```

##### 最佳实践

1. **明确数据归属**：
   - 插件自带的 → Config
   - 用户创建的 → Data
   - 临时缓存/可重新生成的数据 → TempData

2. **选择正确的存储目录**：
   
   // ❌ 错误：将缓存数据放在 Data 目录会导致备份体积过大
   string cacheDir = Path.Combine(Context.DataPath, "cache");
   
   // ✅ 正确：缓存数据应放在 TempData 目录
   string cacheDir = Path.Combine(Context.TempDataPath, "cache");

3. **TempData 使用原则**：
   - 存储的数据应该是"可丢失"的
   - 数据丢失后应该能够通过重新下载/生成恢复
   - 不要存储用户手动创建或编辑的内容
   - 定期清理过期的缓存文件

4. **使用数据库优先**：
   - 简单的键值对 → 使用 `Context.SetValue()` / `GetValue()`
   - 结构化数据 → 使用 `Context.SetSettings()` / `GetSettings()`
   - 大文件/二进制 → 使用 Data 目录
   - 临时数据 → 使用 TempData 目录

5. **文档说明**：

在插件的 README 中说明：
- Config 目录的内容和用途
- Data 目录会存储哪些用户数据
- TempData 目录的内容和用途
- 数据迁移和备份建议

**目录结构**:
```
Plugins/
└── MyPlugin/
    ├── config/      # 配置目录（GetConfigPath()）- 随插件版本更新
    ├── data/        # 数据目录（GetPluginDataPath()）- 会备份至服务器
    ├── temp_data/   # 临时数据目录（GetPluginTempDataPath()）- 不会备份
    ├── dll/         # 插件依赖的库
    ├── plugin.json   # 插件信息文件
    └── MyPlugin.dll
```

### 🔔 通知系统

插件可以显示应用内通知和系统托盘通知：

```csharp
// 应用内通知（窗口内 Toast）
Context!.ShowInAppNotification("操作完成", "数据已成功保存", NotificationType.Success);

// 系统托盘通知
Context!.ShowSystemNotification("新消息", "您有一条新消息", new Dictionary<string, string>
{
    ["查看"] = "view_message",
    ["忽略"] = "ignore_message"
});
```

**注意**: 通知 API 需要通过 `Context` 属性访问（`Context` 是 `public` 的，可以直接访问）。

**通知类型**:
- `NotificationType.Information` - 信息通知
- `NotificationType.Success` - 成功通知
- `NotificationType.Warning` - 警告通知
- `NotificationType.Error` - 错误通知

### ⏳ Loading 指示器

插件可以显示全屏 Loading 指示器：

```csharp
// 显示 Loading（带消息）
Context!.ShowLoading("正在加载数据...");

try
{
    await LoadDataAsync();
}
finally
{
    // 确保隐藏 Loading
    Context!.HideLoading();
}
```

**注意**: Loading API 需要通过 `Context` 属性访问。

**使用建议**:
- 用于长时间运行的操作（> 1秒）
- 必须在 `finally` 块中调用 `HideLoading()`，确保总是隐藏
- 避免嵌套使用

### 🎯 托盘菜单

插件可以添加系统托盘菜单项：

```csharp
public override void OnInit()
{
    base.OnInit();
    
    // 添加菜单项
    Context!.AddTrayMenuItem("myplugin_action", "执行操作", () =>
    {
        Context!.LogInfo("用户点击了托盘菜单项");
        DoSomething();
    });
    
    // 添加分隔符
    Context!.AddTrayMenuSeparator("myplugin_separator");
}

public override void OnDestroy()
{
    // 清理时移除菜单项
    Context!.RemoveTrayMenuItem("myplugin_action");
    Context!.RemoveTrayMenuItem("myplugin_separator");
    base.OnDestroy();
}
```

**注意事项**:
- 菜单项 ID 必须唯一（建议使用插件名前缀）
- 在 `OnDestroy()` 中清理添加的菜单项
- 分隔符也需要通过 `RemoveTrayMenuItem()` 移除

---

## 最佳实践

### 1. 资源管理

实现 `IDisposable` 以正确释放资源：

```csharp
public class MyPlugin : BaseMicroDockPlugin, IDisposable
{
    private Timer? _timer;
    private HttpClient? _httpClient;

    public override void Initialize(IPluginContext context)
    {
        _timer = new Timer(OnTimerTick, null, 0, 1000);
        _httpClient = new HttpClient();
    }

    public void Dispose()
    {
        _timer?.Dispose();
        _httpClient?.Dispose();
    }

    public override void Shutdown()
    {
        Dispose();
    }
}
```

### 2. 错误处理

始终捕获和处理异常，避免插件错误影响主应用：

```csharp
public override void Initialize(IPluginContext context)
{
    try
    {
        // 初始化逻辑
        LoadConfiguration();
        InitializeServices();
    }
    catch (Exception ex)
    {
        Console.WriteLine($"插件初始化失败: {ex.Message}");
        // 可以选择使用日志框架记录错误
    }
}
```

### 3. 异步操作

使用 async/await 处理异步操作：

```csharp
public async Task LoadDataAsync()
{
    try
    {
        var data = await _httpClient.GetStringAsync("https://api.example.com/data");
        // 处理数据
    }
    catch (Exception ex)
    {
        // 错误处理
    }
}
```

### 4. MVVM 模式

遵循 MVVM 模式组织代码：

```
MyPlugin/
├── ViewModels/
│   └── MyTabViewModel.cs
├── Views/
│   └── MyTabView.axaml
│   └── MyTabView.axaml.cs
├── Models/
│   └── MyDataModel.cs
└── MyPlugin.cs
```

### 5. 性能考虑

- **延迟加载**: 仅在需要时加载资源
- **缓存数据**: 避免重复的网络请求或计算
- **避免阻塞 UI**: 将耗时操作放在后台线程

```csharp
// 使用 Task.Run 执行耗时操作
await Task.Run(() =>
{
    // 耗时的数据处理
    ProcessLargeDataSet();
});
```

---

## 常见问题

### Q: 插件如何调试？

**A**: 有两种方法：

1. **控制台输出**: 在插件中使用 `Console.WriteLine()` 输出调试信息
2. **附加调试器**: 在 Visual Studio 中使用 "附加到进程" 功能附加到 MicroDock.exe

### Q: 插件如何访问主应用的服务？

**A**: 通过 ServiceLocator 获取主应用注册的服务：

```csharp
// 注意：需要主应用提供 ServiceLocator 访问权限
var someService = ServiceLocator.GetService<ISomeService>();
```

### Q: 插件可以使用哪些 NuGet 包？

**A**: 您可以使用任何兼容 .NET 8.0 的 NuGet 包，但请注意：
- 避免与主应用的依赖版本冲突
- 大型依赖会增加插件加载时间
- 尽量使用轻量级的库

### Q: 如何处理插件配置？

**A**: 建议将配置保存在插件自己的目录中：

```csharp
private string GetConfigPath()
{
    var pluginDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
    return Path.Combine(pluginDir, "config.json");
}

private void LoadConfig()
{
    var configPath = GetConfigPath();
    if (File.Exists(configPath))
    {
        var json = File.ReadAllText(configPath);
        // 反序列化配置
    }
}
```

### Q: 插件可以添加设置项吗？

**A**: 可以。插件可以提供设置 UI，主应用会在设置页面的"插件设置"区域显示：

```csharp
public class MyPlugin : BaseMicroDockPlugin, IMicroTab
{
    // 提供设置 UI
    public object SettingsControl => new MyPluginSettingsView();
}
```

### Q: 页面内容过多时如何滚动？

**A**: 无需特殊处理！主应用已在 NavigationView 层面提供了统一的滚动支持。只需按正常方式布局您的内容，当内容超出可视区域时会自动显示滚动条。

### Q: 我需要在某个区域实现独立滚动怎么办？

**A**: 如果您需要在特定区域（如列表、文本框）实现独立滚动，可以在该区域使用 ScrollViewer。请参考 [UI 页签开发规范](#ui-页签开发规范) 中的"局部滚动区域"示例。

### Q: 插件如何记录日志？

**A**: 插件可以通过 `Context` 属性访问日志方法：

```csharp
public class MyPlugin : BaseMicroDockPlugin
{
    public override void OnInit()
    {
        Context!.LogDebug("调试信息");
        Context!.LogInfo("一般信息");
        Context!.LogWarning("警告信息");
        Context!.LogError("错误信息", exception);  // 可以包含异常对象
    }
}
```

所有日志都会自动添加插件名称前缀，可以在主应用的"日志查看器"标签页中查看。详细说明请参考 [插件上下文 API - 日志系统](#-日志系统)。

### Q: 插件如何保存和读取数据？

**A**: 插件可以使用键值存储 API 或设置 API：

```csharp
// 键值存储（内部数据）
SetValue("key", "value");
var value = GetValue("key");

// 设置（用户可配置，会在设置界面显示）
SetSettings("api_key", "value", "描述");
var setting = GetSettings("api_key");
```

详细说明请参考 [插件上下文 API](#插件上下文-api) 章节。

### Q: 插件如何显示通知？

**A**: 插件可以通过上下文 API 显示通知：

```csharp
// 应用内通知
Context!.ShowInAppNotification("标题", "消息", NotificationType.Success);

// 系统托盘通知
Context!.ShowSystemNotification("标题", "消息");
```

注意：通知 API 需要通过 `Context` 属性访问（`Context` 是 `public` 的），而不是基类的便捷方法。

---

## 示例插件

### 完整示例：天气插件

参考 `Test` 项目获取完整的插件实现示例：

```
Test/
├── TestPlugin.cs           # 插件主类
├── TestTab.axaml          # UI 定义
└── TestTab.axaml.cs       # UI 代码后端
```

### 更多资源

- **插件框架文档**: [MicroDock.Plugin/CLAUDE.md](../MicroDock.Plugin/CLAUDE.md)
- **主应用模块文档**: [MicroDock/CLAUDE.md](../MicroDock/CLAUDE.md)
- **项目架构文档**: [CLAUDE.md](../CLAUDE.md)

---

## 版本更新日志

### v3.2.0 (2025-11-14)
- 📝 **新增**: 添加完整的插件上下文 API 文档
- ✨ **新增**: 详细的日志系统使用说明和最佳实践
- ✨ **新增**: 数据存储、设置管理、依赖访问等 API 说明
- ✨ **新增**: 图片管理、路径管理、通知系统等 API 说明
- ✨ **新增**: Loading 指示器和托盘菜单 API 说明
- 📝 **完善**: 添加日志相关的常见问题解答
- 📝 **完善**: 更新常见问题，添加数据存储和通知相关问题
- ✅ **修正**: 所有日志示例统一使用 `Context!.LogXXX` 方式访问

### v3.1.0 (2025-11-14)
- 📝 **文档更新**: 基于实际代码更新插件开发指南
- ✅ 修正 `IMicroTab` 接口说明（`IconSymbol` 而非 `IconSource`）
- ✅ 移除不存在的 `IMicroActionsProvider` 接口说明
- ✅ 更正 `CallToolAsync` 参数类型（`Dictionary<string, string>` 而非 `Dictionary<string, object>`）
- ✅ 完善类型转换机制说明（调用者需要序列化复杂对象为 JSON）
- ✅ 添加更详细的参数类型和调用示例
- ✅ 增加 IMicroTab 实现说明（View 类需要继承 UserControl 并实现 IMicroTab）

### v3.0.0 (2025-11-13)
- 🚀 **重大更新**: 引入插件工具调用系统
- ✨ 添加 `MicroToolAttribute` 和 `ToolParameterAttribute` 特性
- ✨ 实现工具自动发现和注册机制
- ✨ 支持强类型参数和自动类型转换
- ✨ 添加 `OnAllPluginsLoaded()` 生命周期回调
- ✨ 实现工具发现 API 和统计功能
- 🎨 设置界面自动显示插件注册的工具
- 📝 详细的工具系统文档和示例
- 📝 更新 Test 插件，添加4个工具示例

### v2.0.0 (2025-11-13)
- 🚀 **重大更新**: 引入 `plugin.json` 配置文件系统
- ✨ 简化插件接口，移除元数据相关属性
- 📝 详细说明 `plugin.json` 所有字段和使用方法
- 📝 添加反向域名命名规范和版本管理说明
- 📝 添加插件依赖管理和版本范围语法
- 📝 更新快速开始指南，适配新的插件开发流程
- 📝 更新示例代码，展示新接口用法
- ⚠️ **破坏性变更**: 不再兼容旧版本插件，所有插件必须提供 plugin.json

### v1.0.0 (2025-11-13)
- ✨ 首次发布插件开发指南
- 📝 添加 ScrollViewer 使用规范
- 📝 添加 UI 页签开发最佳实践
- 📝 添加常见问题解答

---

## 反馈与支持

如果您在插件开发过程中遇到问题或有改进建议，欢迎：
- 提交 Issue 到项目仓库
- 参与项目讨论
- 贡献示例插件代码

祝您开发愉快！🎉

