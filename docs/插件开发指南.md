# MicroDock 插件开发指南

## 版本信息
- **文档版本**: 3.1.0
- **最后更新**: 2025-11-14
- **适用 MicroDock 版本**: 0.0.3.0+

## 目录
- [概述](#概述)
- [plugin.json 配置文件](#pluginjson-配置文件) ⭐ **重要更新**
- [快速开始](#快速开始)
- [插件接口](#插件接口)
- [插件工具系统](#插件工具系统) 🆕 **全新功能**
- [UI 页签开发规范](#ui-页签开发规范)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

---

## 概述

MicroDock 提供了一个灵活的插件系统，允许第三方开发者扩展应用功能。插件可以：
- 添加新的 UI 标签页
- 提供自定义操作和服务
- 集成外部工具和服务

### 技术栈
- **.NET 8.0**: 插件必须基于 .NET 8.0 开发
- **Avalonia UI**: 用于创建跨平台 UI 组件
- **MicroDock.Plugin**: 核心插件框架库

---

## plugin.json 配置文件

### ⭐ 重要更新（v0.0.2.0+）

从 MicroDock v0.0.2.0 开始，**所有插件必须提供 `plugin.json` 配置文件**。这个文件用于定义插件的元数据，插件接口不再需要实现元数据相关的属性。

### 为什么要使用 plugin.json？

- **元数据与代码分离**: 插件元数据不再耦合在代码中，更易于管理和修改
- **无需实例化即可读取**: 框架无需实例化插件类即可获取元数据，提升性能
- **依赖管理**: 支持声明式的依赖关系和版本范围
- **标准化**: 参考 npm 的 package.json，采用业界标准命名规范

### 完整配置示例

```json
{
  "name": "com.company.pluginname",
  "displayName": "插件显示名称",
  "version": "1.0.0",
  "description": "插件的详细描述",
  "author": "作者姓名 <email@example.com>",
  "license": "MIT",
  "homepage": "https://github.com/user/plugin",
  
  "main": "PluginName.dll",
  "entryClass": "Namespace.PluginClassName",
  
  "dependencies": {
    "com.other.plugin": "^2.0.0"
  },
  
  "engines": {
    "microdock": ">=1.0.0"
  }
}
```

### 字段详细说明

#### 必需字段

| 字段 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `name` | string | **插件唯一标识符**，使用反向域名格式 | `"com.example.testplugin"` |
| `version` | string | **语义化版本号** (Semver格式) | `"1.0.0"` |
| `main` | string | **主 DLL 文件名** | `"TestPlugin.dll"` |
| `entryClass` | string | **入口类的完全限定名** | `"Test.TestPlugin"` |

#### 可选字段

| 字段 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `displayName` | string | 显示给用户的友好名称，默认为 `name` | `"测试插件"` |
| `description` | string | 插件的详细描述 | `"这是一个测试插件"` |
| `author` | string | 作者信息 | `"John Doe <john@example.com>"` |
| `license` | string | 开源许可证 | `"MIT"` |
| `homepage` | string | 插件主页 URL | `"https://github.com/..."` |
| `dependencies` | object | 插件依赖（键为插件名，值为版本范围） | `{"com.other.plugin": "^1.0.0"}` |
| `engines` | object | 运行环境要求 | `{"microdock": ">=1.0.0"}` |

### name 字段命名规范

**格式**: `com.company.pluginname`

**规则**:
- 使用反向域名格式（类似 Java 包名）
- 只能包含小写字母、数字、点 `.` 和连字符 `-`
- 每个部分必须以字母开头
- 至少包含两个部分（用点分隔）

**示例**:
- ✅ `com.microdock.test`
- ✅ `com.example.weather-plugin`
- ✅ `org.mycompany.tool`
- ❌ `TestPlugin` （不符合反向域名格式）
- ❌ `com.Example.Plugin` （包含大写字母）
- ❌ `com.123company.plugin` （数字开头）

### version 字段版本格式

**格式**: `主版本.次版本.补丁版本[-预发布版本][+构建元数据]`

**示例**:
- `1.0.0` - 正式版本
- `2.3.1` - 标准版本
- `1.0.0-alpha` - 预发布版本
- `1.0.0-beta.1` - 带序号的预发布版本
- `1.0.0+20231113` - 带构建元数据的版本

### dependencies 依赖管理

#### 版本范围语法

| 格式 | 说明 | 匹配示例 |
|------|------|----------|
| `1.0.0` | 精确版本 | 只匹配 `1.0.0` |
| `^1.0.0` | 兼容版本（主版本相同） | `1.0.0` ~ `1.x.x` |
| `~1.0.0` | 补丁版本（主次版本相同） | `1.0.0` ~ `1.0.x` |
| `>=1.0.0` | 最低版本 | `1.0.0` 及以上 |
| `*` | 任意版本 | 任何版本 |

#### 依赖示例

```json
{
  "dependencies": {
    "com.base.plugin": "^2.0.0",      // 兼容 2.x.x 版本
    "com.utils.plugin": "~1.5.0",     // 兼容 1.5.x 版本
    "com.required.plugin": ">=3.0.0", // 3.0.0 或更高版本
    "com.any.plugin": "*"              // 任意版本
  }
}
```

### 最小配置示例

一个最简单的 `plugin.json` 示例：

```json
{
  "name": "com.example.myplugin",
  "version": "1.0.0",
  "main": "MyPlugin.dll",
  "entryClass": "MyPlugin.MyPluginClass"
}
```

### 项目配置

在 `.csproj` 文件中配置自动复制 `plugin.json`：

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\MicroDock.Plugin\MicroDock.Plugin.csproj" />
  </ItemGroup>

  <!-- 自动复制 plugin.json 到输出目录 -->
  <ItemGroup>
    <None Update="plugin.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>
```

---

## 快速开始

### 1. 创建插件项目

```bash
# 创建新的类库项目
dotnet new classlib -n MyMicroDockPlugin -f net8.0

# 添加对 MicroDock.Plugin 的引用
cd MyMicroDockPlugin
dotnet add reference path/to/MicroDock.Plugin.csproj

# 添加 Avalonia UI 依赖（如果需要创建 UI）
dotnet add package Avalonia --version 11.3.8
```

### 2. 创建 plugin.json

在项目根目录创建 `plugin.json` 文件：

```json
{
  "name": "com.mycompany.myplugin",
  "displayName": "我的插件",
  "version": "1.0.0",
  "description": "这是一个示例插件",
  "author": "Your Name <your.email@example.com>",
  "license": "MIT",
  
  "main": "MyMicroDockPlugin.dll",
  "entryClass": "MyMicroDockPlugin.MyPlugin",
  
  "engines": {
    "microdock": ">=0.0.2.0"
  }
}
```

### 3. 实现插件接口

创建主插件类并实现 `IMicroDockPlugin` 接口：

**注意：从 v0.0.2.0 开始，不再需要在代码中定义元数据属性（如 Name、Version 等），这些信息现在由 plugin.json 管理。**

```csharp
using MicroDock.Plugin;

public class MyPlugin : BaseMicroDockPlugin
{
    // 插件生命周期方法
    public override void OnInit()
    {
        base.OnInit();
        // 插件初始化逻辑
        LogInfo("我的插件已初始化");
    }

    public override void OnEnable()
    {
        base.OnEnable();
        LogInfo("我的插件已启用");
    }

    public override void OnDisable()
    {
        base.OnDisable();
        LogInfo("我的插件已禁用");
    }

    public override void OnDestroy()
    {
        base.OnDestroy();
        // 插件清理逻辑
        LogInfo("我的插件正在销毁");
    }
    
    // 插件标签页配置
    public override IMicroTab[] Tabs => Array.Empty<IMicroTab>();
}
```

### 4. 添加标签页（可选）

如果您的插件需要提供 UI 界面，创建一个标签页视图并在 `Tabs` 属性中返回：

**MyTabView.axaml**:
```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="MyMicroDockPlugin.MyTabView">
    <StackPanel Margin="0,12,12,12" Spacing="8">
        <TextBlock Text="我的标签页" FontSize="16" FontWeight="Bold"/>
        <TextBox Watermark="输入内容..."/>
        <Button Content="提交"/>
    </StackPanel>
</UserControl>
```

**实现 IMicroTab 接口的 View 类**:
```csharp
// MyTabView.axaml.cs
using Avalonia.Controls;
using MicroDock.Plugin;

public partial class MyTabView : UserControl, IMicroTab
{
    public string TabName => "我的标签页";
    public IconSymbolEnum IconSymbol => IconSymbolEnum.GamesFilled;
    
    public MyTabView()
    {
        InitializeComponent();
    }
}
```

**更新插件类**:
```csharp
public class MyPlugin : BaseMicroDockPlugin
{
    private MyTabView? _tabView;
    
    public override IMicroTab[] Tabs
    {
        get
        {
            if (_tabView == null)
            {
                _tabView = new MyTabView();
            }
            return new IMicroTab[] { _tabView };
        }
    }
}
```

### 5. 配置项目文件

更新 `.csproj` 文件，确保 `plugin.json` 被复制到输出目录：

```xml
<ItemGroup>
  <None Update="plugin.json">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
</ItemGroup>
```

### 6. 编译和部署

```bash
# 编译插件
dotnet build -c Release

# 将生成的文件复制到 MicroDock 的 Plugins/PluginName 目录
# 注意：每个插件需要在独立的子文件夹中
mkdir -p path/to/MicroDock/Plugins/MyPlugin
cp bin/Release/net8.0/* path/to/MicroDock/Plugins/MyPlugin/
```

**重要**: 插件必须放在 `Plugins` 目录下的独立子文件夹中，文件夹名称建议与插件名称一致。

---

## 插件接口

### IMicroDockPlugin（核心接口）

所有插件必须实现的基础接口：

```csharp
public interface IMicroDockPlugin
{
    /// <summary>
    /// 初始化插件上下文（由框架调用，之后会调用 OnInit）
    /// </summary>
    void Initialize(IPluginContext context);

    /// <summary>
    /// 所有标签页
    /// </summary>
    IMicroTab[] Tabs { get; }

    /// <summary>
    /// 获取插件的设置UI控件（可选，返回null表示没有设置）
    /// </summary>
    object? GetSettingsControl();

    /// <summary>
    /// 插件初始化
    /// </summary>
    void OnInit();

    /// <summary>
    /// 插件启用
    /// </summary>
    void OnEnable();

    /// <summary>
    /// 插件禁用
    /// </summary>
    void OnDisable();

    /// <summary>
    /// 插件释放
    /// </summary>
    void OnDestroy();
}
```

**重要变更（v0.0.2.0+）**: 
- ❌ 移除了 `Name`, `Version`, `Description`, `Dependencies` 等元数据属性
- ✅ 这些信息现在通过 `plugin.json` 文件管理
- ✅ 简化了插件接口，只保留生命周期和功能相关的方法

### IMicroTab（标签页接口）

用于向主应用添加新的标签页：

```csharp
public interface IMicroTab
{
    /// <summary>
    /// 页签名字
    /// </summary>
    string TabName { get; }
    
    /// <summary>
    /// 页签图标
    /// </summary>
    IconSymbolEnum IconSymbol { get; }
}
```

**重要说明**：
- 实现 `IMicroTab` 接口的类通常是一个 `UserControl`，该控件本身就是标签页的内容
- `IconSymbolEnum` 提供了大量预定义的图标符号（如 `GamesFilled`、`FolderFilled`、`Settings` 等）
- 完整的图标列表请参考 `MicroDock.Plugin.IconSymbolEnum` 枚举

---

## 插件工具系统

### 🆕 全新功能（v0.0.3.0+）

从 MicroDock v0.0.3.0 开始，插件系统引入了**工具调用系统**，允许插件之间通过工具名和参数相互调用功能，类似于 MCP (Model Context Protocol) 的设计理念。

### 工具系统特性

- ✅ **基于特性定义**: 使用 `[MicroTool]` 特性标记方法
- ✅ **强类型参数**: 支持基本类型、复杂对象、泛型等各种参数类型
- ✅ **自动类型转换**: 框架自动处理类型转换和 JSON 序列化
- ✅ **插件名限定**: 可指定调用特定插件的工具
- ✅ **工具发现 API**: 查询所有可用工具及其详细信息
- ✅ **完整文档**: 工具和参数的详细描述
- ✅ **异步执行**: 所有工具调用都是异步的
- ✅ **日志和统计**: 自动记录工具调用和使用统计

### 定义工具

#### 基本工具示例

```csharp
using MicroDock.Plugin;
using System.Threading.Tasks;

public class MyPlugin : BaseMicroDockPlugin
{
    /// <summary>
    /// 简单的字符串反转工具
    /// </summary>
    [MicroTool("string.reverse",
        Description = "反转输入的字符串",
        ReturnDescription = "反转后的字符串")]
    public async Task<string> ReverseString(
        [ToolParameter("input", Description = "要反转的字符串")] 
        string input)
    {
        await Task.CompletedTask;
        return new string(input.Reverse().ToArray());
    }
}
```

#### 复杂参数工具示例

```csharp
/// <summary>
/// 处理复杂数据对象
/// </summary>
[MicroTool("data.filter",
    Description = "过滤数据列表",
    ReturnDescription = "过滤后的数据 JSON")]
public async Task<string> FilterData(
    [ToolParameter("items", Description = "数据列表")] 
    List<MyDataModel> items,
    [ToolParameter("minValue", Description = "最小值", Required = false)] 
    int minValue = 0)
{
    await Task.CompletedTask;
    var filtered = items.Where(x => x.Value >= minValue).ToList();
    return System.Text.Json.JsonSerializer.Serialize(filtered);
}
```

### 工具特性详解

#### MicroToolAttribute

```csharp
[MicroTool("tool.name",
    Description = "工具的详细描述",
    ReturnDescription = "返回值的说明")]
```

- **name**: 工具的唯一标识符（建议使用 `category.action` 格式）
- **Description**: 工具功能的详细描述
- **ReturnDescription**: 返回值的说明

#### ToolParameterAttribute

```csharp
[ToolParameter("paramName",
    Description = "参数的详细描述",
    Required = true)]
```

- **name**: 参数名称
- **Description**: 参数的详细说明
- **Required**: 是否为必需参数（有默认值时自动为 false）

### 工具方法的类型

MicroDock 工具系统支持三种类型的工具方法，每种类型都有其特定的使用场景和性能特征：

#### 1. 静态方法工具 ⚡

**特点**:
- 无需实例，直接调用
- 性能最优，无实例创建开销
- 无法维护状态

**适用场景**:
- 无状态的纯函数工具
- 工具函数、计算、转换等操作
- 性能敏感的场景

**示例**:

```csharp
/// <summary>
/// 静态方法工具示例：格式化日期时间
/// </summary>
[MicroTool("test.static_format_date",
    Description = "静态方法：格式化当前日期时间",
    ReturnDescription = "格式化后的日期时间字符串")]
public static async Task<string> FormatCurrentDate(
    [ToolParameter("format", Description = "日期格式", Required = false)] 
    string format = "yyyy-MM-dd HH:mm:ss")
{
    await Task.CompletedTask;
    return DateTime.Now.ToString(format);
}
```

**优点**:
- ✅ 性能最优，无额外开销
- ✅ 线程安全（无状态）
- ✅ 简单直观

**限制**:
- ❌ 无法访问插件实例的状态
- ❌ 无法使用插件的上下文和服务

#### 2. 插件类实例方法工具 🔌

**特点**:
- 使用插件已有实例
- 性能优，无额外开销
- 可以访问插件状态和资源

**适用场景**:
- 需要访问插件状态或配置
- 需要使用插件上下文服务
- 与插件功能紧密耦合的操作

**示例**:

```csharp
public class MyPlugin : BaseMicroDockPlugin
{
    private int _pluginState = 0;

    [MicroTool("plugin.instance_tool",
        Description = "插件实例方法示例",
        ReturnDescription = "处理结果")]
    public async Task<string> InstanceTool(
        [ToolParameter("param", Description = "参数")] string param)
    {
        // 可以访问插件实例的字段和属性
        _pluginState++;
        LogInfo($"处理参数: {param}, 状态: {_pluginState}");
        
        // 可以使用插件上下文
        var config = GetSettings("config_key");
        
        return await Task.FromResult($"处理完成: {param}");
    }
}
```

**优点**:
- ✅ 无额外实例创建开销
- ✅ 可以访问插件状态和配置
- ✅ 可以使用插件上下文服务

**限制**:
- ❌ 仅限于插件类本身的方法

#### 3. 其他类实例方法工具 ⚠️

**特点**:
- 首次调用时创建实例，后续复用
- 性能：首次调用有创建开销，后续正常
- 可以维护工具的独立状态
- **UI 标识**: 设置界面中显示黄色警告框 "⚠️ 首次调用创建实例，后续复用"

**适用场景**:
- 需要状态管理的辅助工具
- 工具逻辑与插件主类解耦
- 需要复杂状态维护的工具集

**示例**:

```csharp
/// <summary>
/// 辅助类工具示例（演示实例复用和状态管理）
/// </summary>
internal class TestHelper
{
    private int _callCount = 0;
    private readonly List<string> _history = new();

    /// <summary>
    /// 工具：获取调用次数（演示实例复用）
    /// </summary>
    [MicroTool("test.helper_count",
        Description = "返回此工具实例的调用次数（演示实例复用）",
        ReturnDescription = "调用次数")]
    public async Task<string> GetCallCount()
    {
        await Task.CompletedTask;
        _callCount++;
        return $"此实例已被调用 {_callCount} 次";
    }

    /// <summary>
    /// 工具：记录操作历史
    /// </summary>
    [MicroTool("test.helper_reverse",
        Description = "反转字符串并记录历史",
        ReturnDescription = "反转后的字符串")]
    public async Task<string> ReverseString(
        [ToolParameter("text", Description = "要反转的字符串")] string text)
    {
        await Task.CompletedTask;
        var reversed = new string(text.Reverse().ToArray());
        _history.Add($"反转: {text} -> {reversed}");
        return reversed;
    }

    /// <summary>
    /// 工具：获取操作历史
    /// </summary>
    [MicroTool("test.helper_history",
        Description = "获取所有操作历史",
        ReturnDescription = "历史记录（JSON 数组）")]
    public async Task<string> GetHistory()
    {
        await Task.CompletedTask;
        return System.Text.Json.JsonSerializer.Serialize(_history);
    }
}
```

**优点**:
- ✅ 实例复用，避免重复创建
- ✅ 可以维护工具的独立状态
- ✅ 工具逻辑解耦，易于组织

**限制**:
- ❌ 首次调用有创建开销
- ⚠️ 需要有无参构造函数（可以是 private 或 internal）
- ⚠️ 实例在整个应用生命周期内存在，注意状态累积

**注意事项**:
1. **构造函数要求**: 非插件类必须有无参构造函数（可以是 private 或 internal）
2. **线程安全**: 实例创建是线程安全的，但工具方法本身需要自行保证线程安全
3. **状态管理**: 实例在整个应用生命周期内复用，注意状态累积和内存使用
4. **UI 提示**: 设置界面会自动显示黄色警告标识此类工具

#### 性能对比

| 工具类型 | 首次调用 | 后续调用 | 状态维护 | 适用场景 |
|---------|---------|---------|---------|---------|
| 静态方法 | ⚡ 最快 | ⚡ 最快 | ❌ 不支持 | 无状态纯函数 |
| 插件实例方法 | ⚡ 快 | ⚡ 快 | ✅ 插件状态 | 与插件耦合的操作 |
| 其他类实例方法 | 🐢 稍慢 | ⚡ 快 | ✅ 独立状态 | 需要状态的辅助工具 |

#### 选择建议

1. **优先使用静态方法**，除非需要状态管理
2. **需要插件状态时使用插件实例方法**
3. **需要独立状态管理时使用其他类实例方法**
4. **性能敏感场景优先选择静态方法**

### 调用工具

#### 在 OnAllPluginsLoaded 中调用

```csharp
public override void OnAllPluginsLoaded()
{
    base.OnAllPluginsLoaded();
    
    // 等所有插件加载完成后才能安全地调用其他插件的工具
    
    // 1. 调用全局工具（调用第一个匹配的）
    var result1 = await CallToolAsync("string.reverse", new Dictionary<string, string>
    {
        ["input"] = "Hello World"
    });
    
    // 2. 指定插件名调用
    var result2 = await CallToolAsync("math.add", new Dictionary<string, string>
    {
        ["a"] = "10",
        ["b"] = "20"
    }, pluginName: "com.microdock.test");
    
    // 3. 复杂对象参数（需要序列化为 JSON 字符串）
    var items = new List<MyDataModel> { /* ... */ };
    var itemsJson = System.Text.Json.JsonSerializer.Serialize(items);
    var result3 = await CallToolAsync("data.filter", new Dictionary<string, string>
    {
        ["items"] = itemsJson,  // 复杂对象需要先序列化为 JSON 字符串
        ["minValue"] = "10"
    });
}
```

### 工具发现

```csharp
public override void OnAllPluginsLoaded()
{
    base.OnAllPluginsLoaded();
    
    // 获取所有可用工具
    var allTools = GetAvailableTools();
    foreach (var tool in allTools)
    {
        LogInfo($"工具: {tool.Name}");
        LogInfo($"  描述: {tool.Description}");
        LogInfo($"  提供者: {tool.ProviderPlugin}");
        LogInfo($"  参数: {tool.ParametersSummary}");
    }
    
    // 获取指定插件的工具
    var pluginTools = GetPluginTools("com.microdock.test");
    
    // 获取工具详细信息
    var toolInfo = GetToolInfo("string.reverse");
    if (toolInfo != null)
    {
        LogInfo($"返回值: {toolInfo.ReturnDescription}");
        foreach (var param in toolInfo.Parameters)
        {
            LogInfo($"  参数: {param.Name} ({param.TypeName})");
            LogInfo($"    描述: {param.Description}");
            LogInfo($"    必需: {param.Required}");
        }
    }
}
```

### 支持的参数类型

工具方法可以接受以下类型的参数（调用时都以字符串形式传递，框架自动转换）：

#### 基本类型
```csharp
int, string, bool, double, float, long, decimal, byte, short, char
```

**调用示例**：
```csharp
new Dictionary<string, string>
{
    ["age"] = "25",           // int
    ["name"] = "John",        // string
    ["active"] = "true",      // bool
    ["price"] = "19.99"       // double
}
```

#### 可空类型
```csharp
int?, string?, bool?, double? 等
```

**调用示例**：
```csharp
new Dictionary<string, string>
{
    ["optionalAge"] = "25",   // int? (有值)
    ["optionalName"] = "",    // string? (空字符串表示 null)
}
```

#### 集合类型
```csharp
List<T>, Dictionary<TKey, TValue>, T[]
```

**调用示例**：
```csharp
var items = new List<string> { "item1", "item2", "item3" };
var itemsJson = System.Text.Json.JsonSerializer.Serialize(items);

new Dictionary<string, string>
{
    ["items"] = itemsJson  // 需要序列化为 JSON
}
```

#### 复杂类型
任何可 JSON 序列化的类型：

```csharp
public class MyDataModel
{
    public string Name { get; set; }
    public int Value { get; set; }
}
```

**调用示例**：
```csharp
var data = new MyDataModel { Name = "Test", Value = 100 };
var dataJson = System.Text.Json.JsonSerializer.Serialize(data);

new Dictionary<string, string>
{
    ["data"] = dataJson  // 需要序列化为 JSON
}
```

### 类型转换机制

框架会自动处理参数类型转换。由于 `CallToolAsync` 接受 `Dictionary<string, string>` 参数，所以：

1. **字符串参数**: 直接传递
2. **基本类型**: 框架会自动从字符串转换（如 `"42"` → `42`）
3. **复杂类型**: 需要先序列化为 JSON 字符串，框架会自动反序列化

```csharp
// 调用示例：
await CallToolAsync("tool.name", new Dictionary<string, string>
{
    ["intParam"] = "42",              // string -> int (框架自动转换)
    ["stringParam"] = "hello",         // string -> string (直接)
    ["boolParam"] = "true",            // string -> bool (框架自动转换)
    ["complexParam"] = JsonSerializer.Serialize(myObject)  // object -> JSON string -> object (框架反序列化)
});
```

**转换规则**：
- 基本类型（int、bool、double 等）：框架使用 `Convert.ChangeType` 从字符串转换
- 复杂类型（类、列表、字典等）：框架使用 JSON 反序列化
- 可空类型：支持 `null` 字符串或空字符串

### 工具命名规范

建议使用 **分类.操作** 的命名格式：

```csharp
[MicroTool("http.get")]      // HTTP GET 请求
[MicroTool("http.post")]     // HTTP POST 请求
[MicroTool("file.read")]     // 文件读取
[MicroTool("file.write")]    // 文件写入
[MicroTool("string.format")] // 字符串格式化
[MicroTool("math.calculate")] // 数学计算
```

### 错误处理

工具调用可能抛出以下异常：

```csharp
try
{
    var result = await CallToolAsync("tool.name", parameters);
}
catch (ToolNotFoundException ex)
{
    // 工具未找到
    LogError($"工具 {ex.ToolName} 未找到", ex);
}
catch (ToolParameterException ex)
{
    // 参数错误（缺失、类型不匹配等）
    LogError($"参数 {ex.ParameterName} 错误", ex);
}
catch (ToolExecutionException ex)
{
    // 工具执行失败
    LogError($"工具执行失败", ex);
}
```

### UI 展示

在设置界面的"插件管理"部分，会自动显示每个插件注册的工具：

- **工具列表**: 显示所有注册的工具名称
- **悬浮提示**: 鼠标悬停显示详细信息：
  - 工具描述
  - 返回值说明
  - 参数列表和描述
  - 参数类型和是否可选

### 最佳实践

1. **工具设计**: 
   - 保持工具功能单一和明确
   - 使用清晰的命名和详细的描述
   - 返回值统一为 JSON 字符串

2. **参数设计**:
   - 优先使用基本类型，减少序列化开销
   - 为可选参数提供合理的默认值
   - 使用 `Required = false` 明确标记可选参数

3. **异步编程**:
   - 所有工具方法必须是 `async Task<string>`
   - 避免在工具方法中阻塞线程
   - 适当使用 `ConfigureAwait(false)`

4. **错误处理**:
   - 捕获并记录工具内部的异常
   - 返回有意义的错误信息（JSON 格式）
   - 不要让异常传播到框架层

### 工具示例集合

查看 `Test` 插件中的完整示例：
- `test.reverse`: 字符串反转
- `test.add`: 整数相加
- `test.greet`: 格式化问候语（可选参数）
- `test.processData`: 处理复杂对象列表

---

## UI 页签开发规范

### ⚠️ 重要：ScrollViewer 使用规范

**从 MicroDock v0.0.1.0 开始，主应用已在 NavigationView 层面统一处理滚动功能。**

#### ✅ 正确做法

**不要在插件页签的最外层添加 ScrollViewer**。主应用会自动提供滚动支持。

```xml
<!-- ✅ 正确：直接使用布局容器作为根元素 -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="MyPlugin.MyTabView">
    <StackPanel Margin="10" Spacing="8">
        <TextBlock Text="标题"/>
        <TextBox Watermark="输入内容"/>
        <Button Content="提交"/>
        <!-- 更多内容... -->
    </StackPanel>
</UserControl>
```

#### ❌ 错误做法

```xml
<!-- ❌ 错误：不要在最外层添加 ScrollViewer -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="MyPlugin.MyTabView">
    <ScrollViewer VerticalScrollBarVisibility="Auto">
        <StackPanel Margin="10" Spacing="8">
            <!-- 内容... -->
        </StackPanel>
    </ScrollViewer>
</UserControl>
```

#### 📋 局部滚动区域

如果您的插件需要在**特定区域**内实现独立滚动（例如列表、文本框等），可以在该区域使用 ScrollViewer：

```xml
<UserControl>
    <Grid RowDefinitions="Auto,*,Auto">
        <!-- 固定的头部区域 -->
        <StackPanel Grid.Row="0">
            <TextBlock Text="固定头部"/>
        </StackPanel>
        
        <!-- 可滚动的内容区域 -->
        <ScrollViewer Grid.Row="1" 
                      VerticalScrollBarVisibility="Auto">
            <ListBox ItemsSource="{Binding Items}"/>
        </ScrollViewer>
        
        <!-- 固定的底部区域 -->
        <StackPanel Grid.Row="2">
            <Button Content="提交"/>
        </StackPanel>
    </Grid>
</UserControl>
```

### UI 布局建议

#### 推荐的根容器

根据您的布局需求选择合适的容器：

1. **StackPanel**: 简单的垂直/水平堆叠布局
2. **Grid**: 复杂的网格布局
3. **DockPanel**: 停靠式布局
4. **Panel**: 自定义布局

#### 边距和间距

为了保持与主应用的一致性，建议：

```xml
<StackPanel Margin="0,12,12,12" Spacing="8">
    <!-- 内容 -->
</StackPanel>
```

- **Margin**: `0,12,12,12` (左、上、右、下)
- **Spacing**: `8` 像素（元素间距）

### Avalonia 控件使用

#### FluentAvaloniaUI 组件

推荐使用 FluentAvaloniaUI 组件以保持 UI 风格一致：

```xml
<UserControl xmlns:fa="clr-namespace:FluentAvalonia.UI.Controls;assembly=FluentAvalonia">
    <StackPanel>
        <!-- 可折叠的设置面板 -->
        <fa:SettingsExpander Header="设置项" IconSource="Setting">
            <StackPanel>
                <!-- 设置内容 -->
            </StackPanel>
        </fa:SettingsExpander>
    </StackPanel>
</UserControl>
```

#### 常用控件示例

```xml
<!-- 文本输入 -->
<TextBox Watermark="请输入..." 
         AcceptsReturn="True"
         MinHeight="100"/>

<!-- 按钮 -->
<Button Content="操作" 
        Padding="20,8"
        Command="{Binding MyCommand}"/>

<!-- 开关 -->
<ToggleSwitch IsChecked="{Binding IsEnabled}"
              OnContent="开启"
              OffContent="关闭"/>

<!-- 下拉框 -->
<ComboBox ItemsSource="{Binding Options}"
          SelectedItem="{Binding SelectedOption}"/>
```

---

## 最佳实践

### 1. 资源管理

实现 `IDisposable` 以正确释放资源：

```csharp
public class MyPlugin : BaseMicroDockPlugin, IDisposable
{
    private Timer? _timer;
    private HttpClient? _httpClient;

    public override void Initialize()
    {
        _timer = new Timer(OnTimerTick, null, 0, 1000);
        _httpClient = new HttpClient();
    }

    public void Dispose()
    {
        _timer?.Dispose();
        _httpClient?.Dispose();
    }

    public override void Shutdown()
    {
        Dispose();
    }
}
```

### 2. 错误处理

始终捕获和处理异常，避免插件错误影响主应用：

```csharp
public override void Initialize()
{
    try
    {
        // 初始化逻辑
        LoadConfiguration();
        InitializeServices();
    }
    catch (Exception ex)
    {
        Console.WriteLine($"插件初始化失败: {ex.Message}");
        // 可以选择使用日志框架记录错误
    }
}
```

### 3. 异步操作

使用 async/await 处理异步操作：

```csharp
public async Task LoadDataAsync()
{
    try
    {
        var data = await _httpClient.GetStringAsync("https://api.example.com/data");
        // 处理数据
    }
    catch (Exception ex)
    {
        // 错误处理
    }
}
```

### 4. MVVM 模式

遵循 MVVM 模式组织代码：

```
MyPlugin/
├── ViewModels/
│   └── MyTabViewModel.cs
├── Views/
│   └── MyTabView.axaml
│   └── MyTabView.axaml.cs
├── Models/
│   └── MyDataModel.cs
└── MyPlugin.cs
```

### 5. 性能考虑

- **延迟加载**: 仅在需要时加载资源
- **缓存数据**: 避免重复的网络请求或计算
- **避免阻塞 UI**: 将耗时操作放在后台线程

```csharp
// 使用 Task.Run 执行耗时操作
await Task.Run(() =>
{
    // 耗时的数据处理
    ProcessLargeDataSet();
});
```

---

## 常见问题

### Q: 插件如何调试？

**A**: 有两种方法：

1. **控制台输出**: 在插件中使用 `Console.WriteLine()` 输出调试信息
2. **附加调试器**: 在 Visual Studio 中使用 "附加到进程" 功能附加到 MicroDock.exe

### Q: 插件如何访问主应用的服务？

**A**: 通过 ServiceLocator 获取主应用注册的服务：

```csharp
// 注意：需要主应用提供 ServiceLocator 访问权限
var someService = ServiceLocator.GetService<ISomeService>();
```

### Q: 插件可以使用哪些 NuGet 包？

**A**: 您可以使用任何兼容 .NET 8.0 的 NuGet 包，但请注意：
- 避免与主应用的依赖版本冲突
- 大型依赖会增加插件加载时间
- 尽量使用轻量级的库

### Q: 如何处理插件配置？

**A**: 建议将配置保存在插件自己的目录中：

```csharp
private string GetConfigPath()
{
    var pluginDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
    return Path.Combine(pluginDir, "config.json");
}

private void LoadConfig()
{
    var configPath = GetConfigPath();
    if (File.Exists(configPath))
    {
        var json = File.ReadAllText(configPath);
        // 反序列化配置
    }
}
```

### Q: 插件可以添加设置项吗？

**A**: 可以。插件可以提供设置 UI，主应用会在设置页面的"插件设置"区域显示：

```csharp
public class MyPlugin : BaseMicroDockPlugin, IMicroTab
{
    // 提供设置 UI
    public object SettingsControl => new MyPluginSettingsView();
}
```

### Q: 页面内容过多时如何滚动？

**A**: 无需特殊处理！主应用已在 NavigationView 层面提供了统一的滚动支持。只需按正常方式布局您的内容，当内容超出可视区域时会自动显示滚动条。

### Q: 我需要在某个区域实现独立滚动怎么办？

**A**: 如果您需要在特定区域（如列表、文本框）实现独立滚动，可以在该区域使用 ScrollViewer。请参考 [UI 页签开发规范](#ui-页签开发规范) 中的"局部滚动区域"示例。

---

## 示例插件

### 完整示例：天气插件

参考 `Test` 项目获取完整的插件实现示例：

```
Test/
├── TestPlugin.cs           # 插件主类
├── TestTab.axaml          # UI 定义
└── TestTab.axaml.cs       # UI 代码后端
```

### 更多资源

- **插件框架文档**: [MicroDock.Plugin/CLAUDE.md](../MicroDock.Plugin/CLAUDE.md)
- **主应用模块文档**: [MicroDock/CLAUDE.md](../MicroDock/CLAUDE.md)
- **项目架构文档**: [CLAUDE.md](../CLAUDE.md)

---

## 版本更新日志

### v3.1.0 (2025-11-14)
- 📝 **文档更新**: 基于实际代码更新插件开发指南
- ✅ 修正 `IMicroTab` 接口说明（`IconSymbol` 而非 `IconSource`）
- ✅ 移除不存在的 `IMicroActionsProvider` 接口说明
- ✅ 更正 `CallToolAsync` 参数类型（`Dictionary<string, string>` 而非 `Dictionary<string, object>`）
- ✅ 完善类型转换机制说明（调用者需要序列化复杂对象为 JSON）
- ✅ 添加更详细的参数类型和调用示例
- ✅ 增加 IMicroTab 实现说明（View 类需要继承 UserControl 并实现 IMicroTab）

### v3.0.0 (2025-11-13)
- 🚀 **重大更新**: 引入插件工具调用系统
- ✨ 添加 `MicroToolAttribute` 和 `ToolParameterAttribute` 特性
- ✨ 实现工具自动发现和注册机制
- ✨ 支持强类型参数和自动类型转换
- ✨ 添加 `OnAllPluginsLoaded()` 生命周期回调
- ✨ 实现工具发现 API 和统计功能
- 🎨 设置界面自动显示插件注册的工具
- 📝 详细的工具系统文档和示例
- 📝 更新 Test 插件，添加4个工具示例

### v2.0.0 (2025-11-13)
- 🚀 **重大更新**: 引入 `plugin.json` 配置文件系统
- ✨ 简化插件接口，移除元数据相关属性
- 📝 详细说明 `plugin.json` 所有字段和使用方法
- 📝 添加反向域名命名规范和版本管理说明
- 📝 添加插件依赖管理和版本范围语法
- 📝 更新快速开始指南，适配新的插件开发流程
- 📝 更新示例代码，展示新接口用法
- ⚠️ **破坏性变更**: 不再兼容旧版本插件，所有插件必须提供 plugin.json

### v1.0.0 (2025-11-13)
- ✨ 首次发布插件开发指南
- 📝 添加 ScrollViewer 使用规范
- 📝 添加 UI 页签开发最佳实践
- 📝 添加常见问题解答

---

## 反馈与支持

如果您在插件开发过程中遇到问题或有改进建议，欢迎：
- 提交 Issue 到项目仓库
- 参与项目讨论
- 贡献示例插件代码

祝您开发愉快！🎉

