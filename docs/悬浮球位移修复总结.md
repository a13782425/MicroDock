# 悬浮球位移问题修复总结

## 问题概述

悬浮球在展开和收起切换时可能出现位置偏移，主要由以下原因导致：
1. 中心点计算不一致
2. DPI 缩放导致的舍入误差累积
3. 边缘自适应使用展开后的位置判定

## 解决方案

### 1. 创建单元测试项目

创建了 `MicroDock.Tests` 项目，使用 xUnit 框架进行单元测试。

**位置**：`MicroDock.Tests/`
- 15 个单元测试覆盖核心计算逻辑
- 测试不同 DPI 缩放下的表现
- 测试多次展开收起的累积误差

### 2. 提取核心计算逻辑

创建 `WindowPositionCalculator` 静态类，提供 DPI 安全的位置计算方法。

**位置**：`MicroDock/Services/WindowPositionCalculator.cs`

**核心方法**：
- `CalculateCenter()` - 计算窗口中心点（像素坐标）
- `CalculatePositionAroundCenter()` - 围绕中心点计算新位置
- `CalculateNewPosition()` - 保持中心不变调整窗口大小
- `CheckEdgeProximity()` - 检测窗口边缘位置
- `CalculateOptimalArc()` - 计算最佳弧线方向

**关键改进**：
- 使用浮点数计算避免过早舍入
- 统一的 DPI 缩放处理
- 最后再转换为整数像素坐标

### 3. 修复 MiniBallWindow

**改进点**：

#### 3.1 展开逻辑优化
```csharp
// 保存原始位置用于边缘判定
PixelPoint originalPosition = Position;

// 精确计算并保存中心点
_fixedCenterPxDuringExpand = WindowPositionCalculator.CalculateCenter(
    originalPosition, Width, Height, scale);

// 基于固定中心点展开
PixelPoint newPosition = WindowPositionCalculator.CalculatePositionAroundCenter(
    _fixedCenterPxDuringExpand.Value, targetSize, targetSize, scale);
```

#### 3.2 收起逻辑改进
使用保存的固定中心点确保完全回到原位：
```csharp
ResizeWindowAroundCenterPx(64, 64, _fixedCenterPxDuringExpand.Value);
```

### 4. 改进 CircularLauncherView

**边缘自适应优化**：
- 添加 `OriginalWindowPosition` 属性
- 使用展开前的位置进行边缘判定
- 调用 `WindowPositionCalculator` 的边缘检测和弧线计算方法

**位置**：`MicroDock/Views/Controls/CircularLauncherView.axaml.cs`

### 5. 添加调试日志

在关键位置添加调试输出，方便追踪问题：

```csharp
Debug.WriteLine($"[MiniBall] 展开前: Position={originalPosition}, Size={Width}x{Height}, Center={center}, DPI={scale}");
Debug.WriteLine($"[MiniBall] 展开后: Position={Position}, Size={Width}x{Height}");
Debug.WriteLine($"[MiniBall] 收起前: Position={positionBeforeReset}, SavedCenter={center}");
Debug.WriteLine($"[MiniBall] 收起后: Position={Position}");
Debug.WriteLine($"[MiniBall] 位移偏差: {offset}");
```

## 测试结果

### 单元测试
✅ 所有 15 个测试通过
- 中心点计算正确性
- DPI 缩放准确性
- 边缘检测准确性
- 多次操作无累积误差（允许 ≤1 像素误差）

### 构建测试
✅ 主项目构建成功（0 错误，仅有预存在的警告）
✅ 测试项目构建成功

## 如何验证修复

### 1. 查看调试日志

在 Visual Studio 或 Rider 的调试输出窗口中查看：
1. 启动应用并启用迷你模式
2. 长按悬浮球展开
3. 点击空白处或按 Esc 收起
4. 观察输出中的 `[MiniBall]` 日志

**期望结果**：
- `位移偏差` 应该是 `(0, 0)` 或非常接近（≤1 像素）
- 展开前后的 `Center` 应该保持一致

### 2. 实际测试场景

1. **标准 DPI (100%)**
   - 在屏幕中央展开收起多次
   - 验证位置不漂移

2. **高 DPI (125%, 150%, 200%)**
   - 重复上述测试
   - 验证不同缩放下的表现

3. **屏幕边缘**
   - 将悬浮球移到左、右、上、下边缘
   - 展开时应自动选择合适的半环方向
   - 收起后应回到原位

4. **多次操作**
   - 连续展开收起 10 次
   - 验证无累积误差

## 技术亮点

1. **精确的浮点数计算**：避免整数除法和过早舍入
2. **固定中心点策略**：展开前保存，收起时使用
3. **DPI 安全**：统一的缩放处理逻辑
4. **可测试性**：核心逻辑提取为纯函数
5. **边缘智能**：使用原始位置判定避免误判

## 未来改进方向

1. 添加动画过渡使展开收起更平滑
2. 支持自定义边缘阈值
3. 多显示器支持优化
4. 更多边缘情况的测试覆盖

## 相关文件

- `MicroDock/Services/WindowPositionCalculator.cs` - 核心计算逻辑
- `MicroDock/Views/MiniBallWindow.axaml.cs` - 悬浮球窗口
- `MicroDock/Views/Controls/CircularLauncherView.axaml.cs` - 环形启动器
- `MicroDock.Tests/WindowPositionCalculatorTests.cs` - 单元测试

