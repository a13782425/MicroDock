# 迷你模式：全屏透明宿主窗口实施方案与设计

本文为“实施方案”，并被列为 P0 必须项：将悬浮球所在窗口设置为“全屏 + 透明背景”，从而完全避免“展开/收起时的窗口重定位/缩放引发的偏移”，并使非球区域点击穿透到桌面或下层应用。

## 1. 结论摘要
- 在 Windows + Avalonia 11 环境下，“全屏透明窗口 + 局部命中（仅球体/菜单区域）”在技术上是可行的。
- 可通过以下原则达成：
  - 窗口：无边框、TopMost、全屏（覆盖当前屏幕或每个屏幕一窗），Background=Transparent，WindowTransparencyLevel=Transparent。
  - 点击穿透：根容器不设置 Background（或设为透明不命中），仅在“需要响应的控件（球/菜单项）”上设置可命中的背景或 HitTest 可见性，从而让其它区域自然穿透到下层。
  - 交互保持：拖拽移动、长按展开、动画均在“视图层移动/变换”内完成，而非改变窗口大小/位置，彻底规避 DPI/缩放导致的漂移问题。
- 取舍：
  - 优点：彻底消除缩放/定位误差、实现“任意位置展开”视觉效果、命中区域可控、后续可扩展屏幕级体验（例如磁吸/吸附/边缘提示）。
  - 风险：需要处理 Alt+Tab 可见性、输入焦点、性能（透明层+动画）、多显示器覆盖、截图/录屏工具兼容性等。

## 2. 关键设计要点

### 2.1 窗口层设置
- 无框与透明
  - SystemDecorations=None，WindowStyle=None（Avalonia 使用 SystemDecorations）。
  - Background=Transparent。
  - TransparencyLevelHint / WindowTransparencyLevel 设为 Transparent（Avalonia: WindowTransparencyLevel.Transparent）。
- 覆盖范围
  - 单显示器：窗口大小 = 当前屏幕可用区域（或 Bounds）。
  - 多显示器：建议每个屏幕一个窗口，以便命中与穿透逻辑简单、性能更可控；或单一超大窗口覆盖所有屏幕（需要自行处理坐标映射与性能）。
- 其它属性
  - Topmost=true，ShowInTaskbar=false（避免任务栏出现）。
  - CanResize=false，SizeToContent=Manual。
  - 若需要从 Alt+Tab 隐藏，需平台特性（Win32 扩展样式 WS_EX_TOOLWINDOW/WS_EX_APPWINDOW 控制；Avalonia 需平台互操作或后续提供的选项）。

### 2.2 命中与点击穿透
- 原理：Avalonia 的命中测试在控件树内进行；未命中的区域不会拦截鼠标，若窗口为透明且根容器无可命中背景，则事件会穿透到桌面或下层应用。
- 实践建议：
  - Root Grid/Canvas 不设置 Background（或设置为 Transparent 但 IsHitTestVisible=false），防止大面积拦截。
  - 悬浮球与环形菜单项控件：
    - 自身设置命中（例如设 Background、或控件默认可命中）。
    - 非可交互区域（球与菜单之间的空白环）尽量不要有可命中背景。
- 高阶方案（可选）：在 Windows 平台通过 Win32 SetWindowRgn/UpdateLayeredWindowEx 或命中区域 API 做“窗口级命中区域裁剪”，进一步确保只有球/菜单区域可命中；此为 P/Invoke 方案，属于 P2 级增强，非必要。

### 2.3 坐标与动画
- 不再改变 Window 的 Position/Size；而是：
  - 使用 Canvas/TranslateTransform/RenderTransform 在全屏画布内移动“球”的视觉位置。
  - 展开/收起动画仅改变子控件（环形菜单容器）的可见性、透明度、缩放等属性。
- DPI/多屏：
  - 全屏窗口坐标使用设备像素对齐；球与菜单位置使用 Visual 的坐标系即可，避免 DIP 与像素混用的中心点偏移。

### 2.4 交互行为
- 点击/长按/拖拽：
  - 按下后计时长按；超过阈值展开菜单。
  - 拖拽时只移动球的 Visual（例如 Canvas.Left/Top 或 RenderTransform），不移动窗口。
- 收起逻辑：
  - 点击空白区域：由于空白区域不命中，上层窗口将收不到事件。可在“窗口层面”订阅全局鼠标变更（较复杂），或在菜单显示时增加“半透明命中遮罩层，仅覆盖菜单周边”，点击遮罩收起（遮罩自身命中即可，但遮罩应避免覆盖整个屏幕以免影响穿透体验）。
  - ESC 键快捷关闭：窗口 KeyDown 处理仍可生效（窗口在 Topmost 且可聚焦时）。

### 2.5 性能与兼容性
- 性能：透明 + 大面积无绘制一般开销可控；动画期间 GPU 合成占用略增。应注意：
  - 尽量减少整个屏幕区域的重绘；只为球/菜单区域触发 Invalidate。
  - 动画时间与帧率适度。
- 兼容：
  - 旧系统/旧显卡或远程桌面环境下，透明合成能力可能受限；需要在设置中提供降级选项（例如回退到“仅小窗口”策略）。
  - 截图/录屏软件对透明层的处理不统一（有的会把透明层当作黑色/白色背景）。

## 3. 与现有方案对比
- 当前（小窗口 + 展开时改变窗口大小）
  - 优点：实现简单、窗口层稳定可靠。
  - 缺点：DPI/多屏边界下需要复杂的像素级校正，仍可能遇到 1px 级漂移；展开范围受窗口大小限制。
- 全屏透明宿主
  - 优点：完全避免窗口缩放/移动；命中区域完全由视图控制；视觉更自由。
  - 缺点：需要处理穿透与焦点细节；多屏下要管理多个窗口；与系统/工具兼容性需测试。

## 4. 技术实现清单（示意，不改代码）
- 窗口初始化（示例伪代码）：
  - SystemDecorations=None, Topmost=true, ShowInTaskbar=false
  - Background=Transparent
  - TransparencyLevel=WindowTransparencyLevel.Transparent
  - WindowState=Maximized 或根据 Screen.Bounds 设置 Width/Height/Position
- 根布局：
  - <Canvas IsHitTestVisible="False"> 作为根（或 Grid）
  - 悬浮球控件 Ball：放在 Canvas 上，给 Ball 自身 IsHitTestVisible=True/有 Background；通过 Canvas.Left/Top 控制位置
  - 环形菜单：Ball 的子树；展开时可见并参与命中
- 拖拽：
  - PointerPressed/Released/Moved 仅更新 Ball 的位置（不改变 Window）
- 收起：
  - 可选“局部遮罩层”控件（覆盖菜单附近区域，命中后关闭），避免整屏命中导致穿透丢失。

## 5. 测试建议
- 不同 DPI（100/125/150%）与多显示器（左/右/上下排列）组合，长按展开/收起中心不跳动。
- 点击穿透验证：球外区域点击应直接命中下层应用；任务栏/桌面可正常点击。
- Alt+Tab、Win+D、截图/录屏：观察窗口是否异常显示或影响操作。
- 性能：在 60Hz、144Hz 显示器上拖拽与展开动画是否平滑。

## 6. 回退策略
- 默认启用“全屏透明宿主窗口”。如检测到兼容性问题，提供设置开关即时回退到“传统小窗口”方案（无需重启）。
- 记录回退原因与环境信息，便于后续兼容性修复。

## 7. 里程碑建议
- P0：单显示器落地（默认开启），确保点击穿透与交互一致；完善收起逻辑与遮罩策略。
- P1：多显示器支持（每屏一窗或超大窗）、边缘/角落行为优化。
- P2：Alt+Tab/焦点策略细化、平台级命中区域裁剪（Win32）、兼容性适配与性能调优。

—— 以上为讨论与设计沉淀，待你确认后可按此文档推进实现。

---

## FAQ：全屏透明窗口会不会影响透明区域的操作？渲染效率如何？

1) 透明区域的操作是否受影响？
- 默认行为：如果仅把窗口背景设为透明（TransparencyLevelHint=Transparent 或 AcrylicBlur 等），但根容器仍可命中（IsHitTestVisible=true），那么“透明但可命中”的区域仍会拦截鼠标事件，导致下层应用无法收到点击。
- 推荐做法：对“非交互区域”显式关闭命中或做点击穿透。
  - 将根 Overlay 的 IsHitTestVisible=false，仅为球体/菜单控件开启命中；
  - 或在命中测试中按像素/几何区域判断：命中到球/菜单返回 true，否则返回 false，让未命中区域穿透到下层应用；
  - 在 Windows 平台可选更激进方案：把宿主窗口设置为 Topmost，并在非交互阶段应用类似 WS_EX_TRANSPARENT 的行为（Avalonia 层面通过控件的命中关闭即可满足多数需求）。
- 键盘与焦点：只有在交互元素（球/菜单）上时才应获得焦点；透明穿透区域不应抢焦点。可通过在非交互区域不参与 Tab 导航、且不处理 PointerPressed 来实现。

结论：采用“全屏透明 + 精确命中/穿透”的策略后，透明区域不会影响对下层应用的操作，下层点击可如常传递。

2) 全屏情况下的渲染效率
- 合成与重绘成本：全屏透明窗口会参与桌面合成器的合成，但只要你不频繁让整张表面失效（Invalidate），且绝大多数区域完全透明，合成器通常能以接近 O(可见像素) 的成本处理。换言之，热点是“你绘制了多少非透明像素、以多大频率更新”。
- Avalonia 实践建议：
  - 控制重绘范围：只在球体与菜单区域发生动画或变化；避免在每帧对整屏触发无效区域更新。
  - 降低过度绘制：球与菜单控件采用矢量/位图合成，关闭不必要的阴影/模糊，或在动画中降低模糊强度/层数。
  - 缓存静态内容：图标位图（IImage）缓存复用；必要时启用 RenderOptions BitmapCache（在 Avalonia 中等效做法是避免重复解码/创建 Bitmap）。
  - 帧率与动画时长：把淡入淡出控制在 120–180ms，尽量减少高帧率大范围透明渐变。
  - 硬件加速：保持默认的 GPU 合成；在旧硬件/远程桌面下注意性能回退策略（简化特效）。
- 多屏与高 DPI：全屏透明窗口覆盖多个显示器时，像素总量上升，建议按屏幕创建窗口或在单屏范围内布局（常见做法是仅对当前屏全屏），以避免无谓的合成面积。

结论：在“仅小区域绘制 + 局部动画 + 图标缓存”的前提下，全屏透明宿主相对普通小窗并不会显著降低渲染效率；关键在于避免整屏频繁重绘与重度模糊。对大多数独显/核显设备，成本可控。

3) 推荐的关键设置（Avalonia/Windows）
- Window
  - SystemDecorations=None，Topmost=true（按需）；
  - TransparencyLevelHint = [WindowTransparencyLevel.Transparent]（或 AcrylicBlur 视审美取舍）；
  - Background=Transparent；
- 命中策略
  - RootOverlay.IsHitTestVisible=false；
  - 仅为球体与菜单控件开启 IsHitTestVisible=true；
  - 在非交互区域不处理 Pointer 事件，保持穿透；
- 性能
  - 缓存 IImage 图标；
  - 控制动画区域与频率；
  - 避免整屏无效化与大面积高斯模糊。

如需我按本文在代码中落地并默认启用，同时提供设置开关便于回退，我将开始在 MiniBallWindow 中按屏幕尺寸铺满窗口，并严格按照“命中可视区域、其他区域穿透”的原则实现，确保交互无回归。